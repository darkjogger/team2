"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/** ******************************************************************************
 *  (c) 2019 ZondaX GmbH
 *  (c) 2016-2017 Ledger
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ******************************************************************************* */
var CLA = 0x99;
var CHUNK_SIZE = 250;
var APP_KEY = "DOT";
var INS = {
  GET_VERSION: 0x00,
  GET_ADDR_ED25519: 0x01,
  SIGN_ED25519: 0x02
};
var PAYLOAD_TYPE = {
  INIT: 0x00,
  ADD: 0x01,
  LAST: 0x02
};
var ERROR_DESCRIPTION = {
  1: "U2F: Unknown",
  2: "U2F: Bad request",
  3: "U2F: Configuration unsupported",
  4: "U2F: Device Ineligible",
  5: "U2F: Timeout",
  14: "Timeout",
  0x9000: "No errors",
  0x9001: "Device is busy",
  0x6802: "Error deriving keys",
  0x6400: "Execution Error",
  0x6700: "Wrong Length",
  0x6982: "Empty Buffer",
  0x6983: "Output buffer too small",
  0x6984: "Data is invalid",
  0x6985: "Conditions not satisfied",
  0x6986: "Transaction rejected",
  0x6a80: "Bad key handle",
  0x6b00: "Invalid P1/P2",
  0x6d00: "Instruction not supported",
  0x6e00: "Ledger app does not seem to be open",
  0x6f00: "Unknown error",
  0x6f01: "Sign/verify error"
};

function errorCodeToString(statusCode) {
  if (statusCode in ERROR_DESCRIPTION) return ERROR_DESCRIPTION[statusCode];
  return "Unknown Status Code: ".concat(statusCode);
}

var LedgerApp =
/*#__PURE__*/
function () {
  function LedgerApp(transport) {
    var scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : APP_KEY;
    (0, _classCallCheck2.default)(this, LedgerApp);

    if (!transport) {
      throw new Error("Transport has not been defined");
    }

    this.transport = transport;
    transport.decorateAppAPIMethods(this, ["getVersion", "getAddress", "sign"], scrambleKey);
  }

  (0, _createClass2.default)(LedgerApp, [{
    key: "getVersion",
    value: function () {
      var _getVersion = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.transport.send(CLA, INS.GET_VERSION, 0, 0).then(function (response) {
                  var errorCodeData = response.slice(-2);
                  var errorCode = errorCodeData[0] * 256 + errorCodeData[1];
                  var targetId = 0;

                  if (response.length >= 9) {
                    /* eslint-disable no-bitwise */
                    targetId = (response[5] << 24) + (response[6] << 16) + (response[7] << 8) + (response[8] << 0);
                    /* eslint-enable no-bitwise */
                  }

                  return {
                    return_code: errorCode,
                    error_message: errorCodeToString(errorCode),
                    //
                    test_mode: response[0] !== 0,
                    major: response[1],
                    minor: response[2],
                    patch: response[3],
                    device_locked: response[4] === 1,
                    target_id: targetId.toString(16)
                  };
                }, LedgerApp.processErrorResponse));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getVersion() {
        return _getVersion.apply(this, arguments);
      }

      return getVersion;
    }()
  }, {
    key: "getAddress",
    value: function () {
      var _getAddress = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(account, change, addressIndex) {
        var requireConfirmation,
            bip44Path,
            p1,
            _args2 = arguments;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                requireConfirmation = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : false;
                bip44Path = LedgerApp.serializeBIP44(account, change, addressIndex);
                p1 = 0;
                if (requireConfirmation) p1 = 1;
                return _context2.abrupt("return", this.transport.send(CLA, INS.GET_ADDR_ED25519, p1, 0, bip44Path).then(function (response) {
                  var errorCodeData = response.slice(-2);
                  var errorCode = errorCodeData[0] * 256 + errorCodeData[1];
                  return {
                    pubKey: response.slice(0, 32).toString("hex"),
                    address: response.slice(32, response.length - 2).toString("ascii"),
                    return_code: errorCode,
                    error_message: errorCodeToString(errorCode)
                  };
                }, LedgerApp.processErrorResponse));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getAddress(_x, _x2, _x3) {
        return _getAddress.apply(this, arguments);
      }

      return getAddress;
    }()
  }, {
    key: "signSendChunk",
    value: function () {
      var _signSendChunk = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(chunkIdx, chunkNum, chunk) {
        var payloadType;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                payloadType = PAYLOAD_TYPE.ADD;

                if (chunkIdx === 1) {
                  payloadType = PAYLOAD_TYPE.INIT;
                }

                if (chunkIdx === chunkNum) {
                  payloadType = PAYLOAD_TYPE.LAST;
                }

                return _context3.abrupt("return", this.transport.send(CLA, INS.SIGN_ED25519, payloadType, 0, chunk, [0x9000, 0x6984, 0x6a80]).then(function (response) {
                  var errorCodeData = response.slice(-2);
                  var returnCode = errorCodeData[0] * 256 + errorCodeData[1];
                  var errorMessage = errorCodeToString(returnCode);
                  var signature = null;

                  if (returnCode === 0x6a80 || returnCode === 0x6984) {
                    errorMessage = response.slice(0, response.length - 2).toString("ascii");
                  } else if (response.length > 2) {
                    signature = response.slice(0, response.length - 2);
                  }

                  return {
                    signature: signature,
                    return_code: returnCode,
                    error_message: errorMessage
                  };
                }, LedgerApp.processErrorResponse));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function signSendChunk(_x4, _x5, _x6) {
        return _signSendChunk.apply(this, arguments);
      }

      return signSendChunk;
    }()
  }, {
    key: "sign",
    value: function () {
      var _sign = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(account, change, addressIndex, message) {
        var _this = this;

        var chunks;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                chunks = LedgerApp.signGetChunks(account, change, addressIndex, message);
                return _context5.abrupt("return", this.signSendChunk(1, chunks.length, chunks[0]).then(
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2.default)(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee4(result) {
                    var i;
                    return _regenerator.default.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            i = 1;

                          case 1:
                            if (!(i < chunks.length)) {
                              _context4.next = 10;
                              break;
                            }

                            _context4.next = 4;
                            return _this.signSendChunk(1 + i, chunks.length, chunks[i]);

                          case 4:
                            result = _context4.sent;

                            if (!(result.return_code !== 0x9000)) {
                              _context4.next = 7;
                              break;
                            }

                            return _context4.abrupt("break", 10);

                          case 7:
                            i += 1;
                            _context4.next = 1;
                            break;

                          case 10:
                            return _context4.abrupt("return", {
                              return_code: result.return_code,
                              error_message: result.error_message,
                              signature: result.signature
                            });

                          case 11:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x11) {
                    return _ref.apply(this, arguments);
                  };
                }(), LedgerApp.processErrorResponse));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function sign(_x7, _x8, _x9, _x10) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
  }], [{
    key: "serializeBIP44",
    value: function serializeBIP44(account, change, addressIndex) {
      if (!Number.isInteger(account)) throw new Error("Input must be an integer");
      if (!Number.isInteger(change)) throw new Error("Input must be an integer");
      if (!Number.isInteger(addressIndex)) throw new Error("Input must be an integer");
      var buf = Buffer.alloc(20);
      buf.writeUInt32LE(0x8000002c, 0);
      buf.writeUInt32LE(0x800001b2, 4); // eslint-disable-next-line no-bitwise

      buf.writeUInt32LE(account, 8); // eslint-disable-next-line no-bitwise

      buf.writeUInt32LE(change, 12); // eslint-disable-next-line no-bitwise

      buf.writeUInt32LE(addressIndex, 16);
      return buf;
    }
  }, {
    key: "signGetChunks",
    value: function signGetChunks(account, change, addressIndex, message) {
      var chunks = [];
      var bip44Path = LedgerApp.serializeBIP44(account, change, addressIndex);
      chunks.push(bip44Path);
      var buffer = Buffer.from(message);

      for (var i = 0; i < buffer.length; i += CHUNK_SIZE) {
        var end = i + CHUNK_SIZE;

        if (i > buffer.length) {
          end = buffer.length;
        }

        chunks.push(buffer.slice(i, end));
      }

      return chunks;
    }
  }, {
    key: "processErrorResponse",
    value: function processErrorResponse(response) {
      return {
        return_code: response.statusCode,
        error_message: errorCodeToString(response.statusCode)
      };
    }
  }]);
  return LedgerApp;
}();

exports.default = LedgerApp;