{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _apiDerive = _interopRequireDefault(require(\"@polkadot/api-derive\"));\n\nvar _util = require(\"@polkadot/api-derive/util\");\n\nvar _Decorated = _interopRequireDefault(require(\"@polkadot/metadata/Decorated\"));\n\nvar _rpcCore = _interopRequireDefault(require(\"@polkadot/rpc-core\"));\n\nvar _rpcProvider = require(\"@polkadot/rpc-provider\");\n\nvar _types = require(\"@polkadot/types\");\n\nvar _Linkage = require(\"@polkadot/types/codec/Linkage\");\n\nvar _constants = require(\"@polkadot/types/extrinsic/constants\");\n\nvar _StorageKey = require(\"@polkadot/types/primitive/StorageKey\");\n\nvar _util2 = require(\"@polkadot/util\");\n\nvar _submittable = require(\"../submittable\");\n\nvar _augmentObject = _interopRequireDefault(require(\"../util/augmentObject\"));\n\nvar _decorate = require(\"../util/decorate\");\n\nvar _validate = require(\"../util/validate\");\n\nvar _Events = _interopRequireDefault(require(\"./Events\")); // Copyright 2017-2020 @polkadot/api authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst PAGE_SIZE_KEYS = 256;\nconst PAGE_SIZE_VALS = PAGE_SIZE_KEYS;\nconst l = (0, _util2.logger)('api/init');\n\nclass Decorate extends _Events.default {\n  // HACK Use BN import so decorateDerive works... yes, wtf.\n\n  /**\n   * This is the one and only method concrete children classes need to implement.\n   * It's a higher-order function, which takes one argument\n   * `method: Method extends (...args: any[]) => Observable<any>`\n   * (and one optional `options`), and should return the user facing method.\n   * For example:\n   * - For ApiRx, `decorateMethod` should just be identity, because the input\n   * function is already an Observable\n   * - For ApiPromise, `decorateMethod` should return a function that takes all\n   * the parameters from `method`, adds an optional `callback` argument, and\n   * returns a Promise.\n   *\n   * We could easily imagine other user-facing interfaces, which are simply\n   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n   * via `decorateMethod`.\n   */\n\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options, type, decorateMethod) {\n    super();\n    this.registry = void 0;\n    this.__phantom = new _bn.default(0);\n    this._consts = {};\n    this._derive = void 0;\n    this._extrinsics = void 0;\n    this._extrinsicType = _constants.DEFAULT_VERSION;\n    this._genesisHash = void 0;\n    this._isConnected = void 0;\n    this._isReady = false;\n    this._options = void 0;\n    this._query = {};\n    this._queryMulti = void 0;\n    this._rpc = void 0;\n    this._rpcCore = void 0;\n    this._runtimeChain = void 0;\n    this._runtimeMetadata = void 0;\n    this._runtimeVersion = void 0;\n    this._rx = {\n      consts: {},\n      query: {},\n      tx: {}\n    };\n    this._type = void 0;\n    this._decorateMethod = void 0;\n\n    this._rxDecorateMethod = method => {\n      return method;\n    };\n\n    this.registry = options.registry || new _types.TypeRegistry();\n    const thisProvider = options.source ? options.source._rpcCore.provider.clone() : options.provider || new _rpcProvider.WsProvider();\n    this._decorateMethod = decorateMethod;\n    this._options = options;\n    this._type = type;\n    this._rpcCore = new _rpcCore.default(this.registry, thisProvider, this._options.rpc);\n    this._isConnected = new _rxjs.BehaviorSubject(this._rpcCore.provider.isConnected());\n    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n    this._rx.registry = this.registry;\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createType(type, ...params) {\n    return this.registry.createType(type, ...params);\n  }\n  /**\n   * @description Register additional user-defined of chain-specific types in the type registry\n   */\n\n\n  registerTypes(types) {\n    types && this.registry.register(types);\n  }\n  /**\n   * @returns `true` if the API operates with subscriptions\n   */\n\n\n  get hasSubscriptions() {\n    return this._rpcCore.provider.hasSubscriptions;\n  }\n\n  injectMetadata(metadata, fromEmpty) {\n    const decoratedMeta = new _Decorated.default(this.registry, metadata);\n\n    if (fromEmpty || !this._extrinsics) {\n      this._extrinsics = this._decorateExtrinsics(decoratedMeta.tx, this._decorateMethod);\n      this._rx.tx = this._decorateExtrinsics(decoratedMeta.tx, this._rxDecorateMethod);\n    } else {\n      (0, _augmentObject.default)('tx', this._decorateExtrinsics(decoratedMeta.tx, this._decorateMethod), this._extrinsics, false);\n      (0, _augmentObject.default)('', this._decorateExtrinsics(decoratedMeta.tx, this._rxDecorateMethod), this._rx.tx, false);\n    } // this API\n\n\n    (0, _augmentObject.default)('query', this._decorateStorage(decoratedMeta.query, this._decorateMethod), this._query, fromEmpty);\n    (0, _augmentObject.default)('consts', decoratedMeta.consts, this._consts, fromEmpty); // rx\n\n    (0, _augmentObject.default)('', this._decorateStorage(decoratedMeta.query, this._rxDecorateMethod), this._rx.query, fromEmpty);\n    (0, _augmentObject.default)('', decoratedMeta.consts, this._rx.consts, fromEmpty);\n  }\n\n  _decorateFunctionMeta(input, output) {\n    output.meta = input.meta;\n    output.method = input.method;\n    output.section = input.section;\n    output.toJSON = input.toJSON;\n\n    if (input.callIndex) {\n      output.callIndex = input.callIndex;\n    }\n\n    return output;\n  } // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n  // manner to cater for both old and new:\n  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n  //   - when non-zero, remove anything that is not in the array (we don't do this)\n\n\n  async _filterRpc() {\n    let methods;\n\n    try {\n      // we ignore the version (adjust as versions change, for now only \"1\")\n      methods = (await this._rpcCore.rpc.methods().toPromise()).methods.map(t => t.toString());\n    } catch (error) {\n      // the method is not there, we adjust accordingly\n      methods = [];\n    }\n\n    this._filterRpcMethods(methods);\n  }\n\n  _filterRpcMethods(exposed) {\n    const hasResults = exposed.length !== 0;\n    const allKnown = [...this._rpcCore.mapping.entries()];\n    const allKeys = allKnown.reduce((allKeys, [, {\n      alias,\n      method,\n      pubsub,\n      section\n    }]) => {\n      allKeys.push(`${section}_${method}`);\n\n      if (pubsub) {\n        allKeys.push(`${section}_${pubsub[1]}`);\n        allKeys.push(`${section}_${pubsub[2]}`);\n      }\n\n      if (alias) {\n        allKeys.push(...alias);\n      }\n\n      return allKeys;\n    }, []);\n    const unknown = exposed.filter(key => !allKeys.includes(key));\n\n    if (unknown.length) {\n      l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n    } // loop through all entries we have (populated in decorate) and filter as required\n    // only remove when we have results and method missing, or with no results if optional\n\n\n    allKnown.filter(([key]) => hasResults ? !exposed.includes(key) && key !== 'rpc_methods' // rpc_methods doesn't appear, v1\n    : key === 'rpc_methods' // we didn't find this one, remove\n    ) // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    .forEach(([_, {\n      method,\n      section\n    }]) => {\n      delete this._rpc[section][method];\n      delete this._rpcCore[section][method];\n      delete this._rx.rpc[section][method];\n    });\n  }\n\n  _decorateRpc(rpc, decorateMethod) {\n    return rpc.sections.reduce((out, _sectionName) => {\n      const sectionName = _sectionName; // out and section here are horrors to get right from a typing perspective :(\n\n      out[sectionName] = Object.entries(rpc[sectionName]).reduce((section, [methodName, method]) => {\n        //  skip subscriptions where we have a non-subscribe interface\n        if (this.hasSubscriptions || !(methodName.startsWith('subscribe') || methodName.startsWith('unsubscribe'))) {\n          section[methodName] = decorateMethod(method, {\n            methodName\n          }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n          section[methodName].raw = decorateMethod(method.raw, {\n            methodName\n          });\n        }\n\n        return section;\n      }, {});\n      return out;\n    }, {});\n  }\n\n  _decorateMulti(decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => this._rpcCore.state.subscribeStorage(calls.map(arg => // the input is a QueryableStorageEntry, convert to StorageEntry\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    Array.isArray(arg) ? [arg[0].creator, ...arg.slice(1)] : [arg.creator])));\n  }\n\n  _decorateExtrinsics(extrinsics, decorateMethod) {\n    const creator = (0, _submittable.createSubmittable)(this._type, this._rx, decorateMethod);\n    return Object.entries(extrinsics).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateExtrinsicEntry(method, creator);\n        return out;\n      }, {});\n      return out;\n    }, creator);\n  }\n\n  _decorateExtrinsicEntry(method, creator) {\n    const decorated = (...params) => creator(method(...params)); // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return this._decorateFunctionMeta(method, decorated);\n  }\n\n  _decorateStorage(storage, decorateMethod) {\n    return Object.entries(storage).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateStorageEntry(method, decorateMethod);\n        return out;\n      }, {});\n      return out;\n    }, {});\n  }\n\n  _decorateStorageEntry(creator, decorateMethod) {\n    // get the storage arguments, with DoubleMap as an array entry, otherwise spread\n    const getArgs = (...args) => (0, _validate.extractStorageArgs)(creator, args); // FIXME We probably want to be able to query the full list with non-subs as well\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\n    const decorated = this.hasSubscriptions && creator.iterKey && creator.meta.type.isMap && creator.meta.type.asMap.linked.isTrue ? this._decorateStorageLinked(creator, decorateMethod) : decorateMethod((...args) => this.hasSubscriptions ? this._rpcCore.state // Unfortunately for one-shot calls we also use .subscribeStorage here\n    .subscribeStorage([getArgs(...args)]) // state_storage returns an array of values, since we have just subscribed to\n    // a single entry, we pull that from the array and return it as-is\n    .pipe((0, _operators.map)(([data]) => data)) : this._rpcCore.state.getStorage(getArgs(...args)), {\n      methodName: creator.method\n    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n    decorated.creator = creator; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment\n\n    decorated.at = decorateMethod((hash, arg1, arg2) => this._rpcCore.state.getStorage(getArgs(arg1, arg2), hash)); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment\n\n    decorated.hash = decorateMethod((arg1, arg2) => this._rpcCore.state.getStorageHash(getArgs(arg1, arg2))); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n    decorated.key = (arg1, arg2) => (0, _util2.u8aToHex)((0, _util2.compactStripLength)(creator(creator.meta.type.isDoubleMap ? [arg1, arg2] : arg1))[1]); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n\n    decorated.keyPrefix = key1 => (0, _util2.u8aToHex)(creator.keyPrefix(key1)); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment\n\n\n    decorated.range = decorateMethod((range, arg1, arg2) => this._decorateStorageRange(decorated, [arg1, arg2], range)); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment\n\n    decorated.size = decorateMethod((arg1, arg2) => this._rpcCore.state.getStorageSize(getArgs(arg1, arg2))); // .keys() & .entries() only available on map types\n\n    if (creator.iterKey && (creator.meta.type.isMap || creator.meta.type.isDoubleMap)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment\n      decorated.entries = decorateMethod((0, _util.memo)(doubleMapArg => this._retrieveMapEntries(creator, doubleMapArg))); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment\n\n      decorated.keys = decorateMethod((0, _util.memo)(doubleMapArg => this._retrieveMapKeys(creator, doubleMapArg)));\n    } // only support multi where subs are available\n\n\n    if (this.hasSubscriptions) {\n      // When using double map storage function, user need to pass double map key as an array\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment\n      decorated.multi = decorateMethod(args => this._rpcCore.state.subscribeStorage(args.map(arg => [creator, arg])));\n    }\n\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n\n  _decorateStorageRange(decorated, args, range) {\n    const outputType = (0, _StorageKey.unwrapStorageType)(decorated.creator.meta.type, decorated.creator.meta.modifier.isOptional);\n    return this._rpcCore.state.queryStorage([decorated.key(...args)], ...range).pipe((0, _operators.map)(result => result.map(([blockHash, [value]]) => [blockHash, this.createType(outputType, value.isSome ? value.unwrap().toHex() : undefined)])));\n  }\n\n  _decorateStorageLinked(creator, decorateMethod) {\n    const result = new Map();\n    let subject;\n    let head = null;\n    const iterKey = creator.iterKey;\n    (0, _util2.assert)(iterKey, 'iterKey field is missing'); // retrieve a value based on the key, iterating if it has a next entry. Since\n    // entries can be re-linked in the middle of a list, we subscribe here to make\n    // sure we catch any updates, no matter the list position\n\n    const getNext = key => this._rpcCore.state.getStorage([creator, key]).pipe((0, _operators.switchMap)(_data => {\n      const data = creator.meta.modifier.isOptional ? _data.unwrapOr(null) : _data;\n      result.set(key, data); // iterate from this key to the linkages, constructing entries for all\n      // those found and available\n\n      if (data && data[1].next.isSome) {\n        return getNext(data[1].next.unwrap());\n      }\n\n      const [keys, vals] = [[], []];\n      let nextKey = head; // loop through the results collected, starting at the head an re-creating\n      // the list. Our map may have old entries, based on the linking these will\n      // not be returned in the final result\n\n      while (nextKey) {\n        var _linkage$next;\n\n        const entry = result.get(nextKey);\n\n        if (!entry) {\n          break;\n        }\n\n        const [item, linkage] = entry;\n        keys.push(nextKey);\n        vals.push(item);\n        nextKey = (_linkage$next = linkage.next) === null || _linkage$next === void 0 ? void 0 : _linkage$next.unwrapOr(null);\n      }\n\n      const nextResult = vals.length ? new _Linkage.LinkageResult(this.registry, [keys[0].constructor, keys], [vals[0].constructor, vals]) : new _Linkage.LinkageResult(this.registry, [_types.Null, []], [_types.Null, []]); // we set our result into a subject so we have a single observable for\n      // which the value changes over time. Initially create, follow-up next\n\n      if (subject) {\n        subject.next(nextResult);\n      } else {\n        subject = new _rxjs.BehaviorSubject(nextResult);\n      }\n\n      return subject;\n    })); // this handles the case where the head changes effectively, i.e. a new entry\n    // appears at the top of the list, the new getNext gets kicked off\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return decorateMethod((...args) => args.length ? this._rpcCore.state // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    .subscribeStorage([[creator, ...args]]).pipe((0, _operators.map)(([data]) => data)) : this._rpcCore.state.subscribeStorage([iterKey()]).pipe((0, _operators.switchMap)(([key]) => getNext(head = key))));\n  }\n\n  _retrieveMapKeys({\n    iterKey,\n    meta\n  }, arg) {\n    (0, _util2.assert)(iterKey && (meta.type.isMap || meta.type.isDoubleMap), 'keys can only be retrieved on maps, linked maps and double maps');\n    const headKey = iterKey(arg).toHex();\n    const startSubject = new _rxjs.BehaviorSubject(headKey);\n    return this._rpcCore.state.getKeysPaged ? startSubject.pipe((0, _operators.switchMap)(startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_KEYS, startKey).pipe((0, _operators.map)(keys => keys.map(key => key.setMeta(meta))))), (0, _operators.tap)(keys => {\n      keys.length === PAGE_SIZE_KEYS ? startSubject.next(keys[PAGE_SIZE_KEYS - 1].toHex()) : startSubject.complete();\n    }), (0, _operators.toArray)(), // toArray since we want to startSubject to be completed\n    (0, _operators.map)(keysArr => keysArr.reduce((result, keys) => result.concat(keys), []))) : this._rpcCore.state.getKeys(headKey).pipe((0, _operators.map)(keys => keys.map(key => key.setMeta(meta))));\n  }\n\n  _retrieveMapEntries(entry, arg) {\n    return this._retrieveMapKeys(entry, arg).pipe((0, _operators.switchMap)(keys => (0, _rxjs.combineLatest)([(0, _rxjs.of)(keys), ...Array(Math.ceil(keys.length / PAGE_SIZE_VALS)).fill(0).map((_, index) => {\n      const keyset = keys.slice(index * PAGE_SIZE_VALS, index * PAGE_SIZE_VALS + PAGE_SIZE_VALS);\n      return this._rpcCore.state.queryStorageAt ? this._rpcCore.state.queryStorageAt(keyset) : this._rpcCore.state.subscribeStorage(keyset).pipe((0, _operators.take)(1));\n    })])), (0, _operators.map)(([keys, ...valsArr]) => valsArr.reduce((result, vals) => result.concat(vals), []).map((value, index) => [keys[index], value])));\n  }\n\n  _decorateDeriveRx(decorateMethod) {\n    // Pull in derive from api-derive\n    const derive = (0, _apiDerive.default)(this._rx, this._options.derives);\n    return (0, _decorate.decorateSections)(derive, decorateMethod);\n  }\n\n  _decorateDerive(decorateMethod) {\n    return (0, _decorate.decorateSections)(this._rx.derive, decorateMethod);\n  }\n  /**\n   * Put the `this.onCall` function of ApiRx here, because it is needed by\n   * `api._rx`.\n   */\n\n\n}\n\nexports.default = Decorate;","map":null,"metadata":{},"sourceType":"script"}