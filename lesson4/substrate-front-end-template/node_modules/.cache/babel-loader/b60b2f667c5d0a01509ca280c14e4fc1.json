{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Struct = _interopRequireDefault(require(\"../../codec/Struct\"));\n\nvar _constants = require(\"../constants\");\n\nvar _ExtrinsicPayload = _interopRequireDefault(require(\"./ExtrinsicPayload\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name GenericExtrinsicSignatureV1\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\n\n\nclass ExtrinsicSignatureV1 extends _Struct.default {\n  // Signature Information.\n  //   1/3/5/9/33 bytes: The signing account identity, in Address format\n  //   64 bytes: The sr25519/ed25519 signature of the Signing Payload\n  //   1-8 bytes: The Compact<Nonce> of the signing account\n  //   1/2 bytes: The Transaction Era\n  constructor(registry, value, {\n    isSigned\n  } = {}) {\n    super(registry, {\n      signer: 'Address',\n      // eslint-disable-next-line sort-keys\n      signature: 'Signature',\n      // eslint-disable-next-line sort-keys\n      nonce: 'Compact<Index>',\n      // eslint-disable-next-line sort-keys\n      era: 'ExtrinsicEra'\n    }, ExtrinsicSignatureV1.decodeExtrinsicSignature(value, isSigned));\n  }\n  /** @internal */\n\n\n  static decodeExtrinsicSignature(value, isSigned = false) {\n    if (!value) {\n      return _constants.EMPTY_U8A;\n    } else if (value instanceof ExtrinsicSignatureV1) {\n      return value;\n    }\n\n    return isSigned ? value : _constants.EMPTY_U8A;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.isSigned ? super.encodedLength : 0;\n  }\n  /**\n   * @description `true` if the signature is valid\n   */\n\n\n  get isSigned() {\n    return !this.signature.isEmpty;\n  }\n  /**\n   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n   */\n\n\n  get era() {\n    return this.get('era');\n  }\n  /**\n   * @description The [[Index]] for the signature\n   */\n\n\n  get nonce() {\n    return this.get('nonce');\n  }\n  /**\n   * @description The actual [[Signature]] hash\n   */\n\n\n  get signature() {\n    return this.get('signature');\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n\n\n  get signer() {\n    return this.get('signer');\n  }\n  /**\n   * @description Forwards compat\n   */\n\n\n  get tip() {\n    return this.registry.createType('Compact<Balance>', 0);\n  }\n\n  _injectSignature(signer, signature, {\n    era,\n    nonce\n  }) {\n    this.set('era', era);\n    this.set('nonce', nonce);\n    this.set('signer', signer);\n    this.set('signature', signature);\n    return this;\n  }\n  /**\n   * @description Adds a raw signature\n   */\n\n\n  addSignature(signer, signature, payload) {\n    return this._injectSignature(this.registry.createType('Address', signer), this.registry.createType('Signature', signature), new _ExtrinsicPayload.default(this.registry, payload));\n  }\n  /**\n   * @description Creates a payload from the supplied options\n   */\n\n\n  createPayload(method, {\n    blockHash,\n    era,\n    genesisHash,\n    nonce\n  }) {\n    return new _ExtrinsicPayload.default(this.registry, {\n      blockHash,\n      era: era || _constants.IMMORTAL_ERA,\n      genesisHash,\n      method: method.toHex(),\n      nonce,\n      // unused for v1, added for compat\n      specVersion: 0,\n      tip: 0,\n      transactionVersion: 0\n    });\n  }\n  /**\n   * @description Generate a payload and applies the signature from a keypair\n   */\n\n\n  sign(method, account, options) {\n    const address = account.publicKey.length > 32 ? (0, _utilCrypto.blake2AsU8a)(account.publicKey, 256) : account.publicKey;\n    const signer = this.registry.createType('Address', address);\n    const payload = this.createPayload(method, options);\n    const signature = this.registry.createType('Signature', payload.sign(account));\n    return this._injectSignature(signer, signature, payload);\n  }\n  /**\n   * @description Generate a payload and applies a fake signature\n   */\n\n\n  signFake(method, address, options) {\n    const signer = this.registry.createType('Address', address);\n    const payload = this.createPayload(method, options);\n    const signature = this.registry.createType('Signature', new Uint8Array(64).fill(0x42));\n    return this._injectSignature(signer, signature, payload);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isSigned ? super.toU8a(isBare) : _constants.EMPTY_U8A;\n  }\n\n}\n\nexports.default = ExtrinsicSignatureV1;","map":null,"metadata":{},"sourceType":"script"}