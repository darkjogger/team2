{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._eraExposure = _eraExposure;\nexports.eraExposure = eraExposure;\nexports._erasExposure = _erasExposure;\nexports.erasExposure = erasExposure;\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _util = require(\"../util\"); // Copyright 2017-2020 @polkadot/api-derive authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst CACHE_KEY = 'eraExposure';\n\nfunction mapStakers(era, stakers) {\n  const nominators = {};\n  const validators = {};\n  stakers.forEach(([key, exposure]) => {\n    const validatorId = key.args[1].toString();\n    validators[validatorId] = exposure;\n    exposure.others.forEach(({\n      who\n    }, validatorIndex) => {\n      const nominatorId = who.toString();\n      nominators[nominatorId] = nominators[nominatorId] || [];\n      nominators[nominatorId].push({\n        validatorId,\n        validatorIndex\n      });\n    });\n  });\n  return {\n    era,\n    nominators,\n    validators\n  };\n}\n\nfunction _eraExposure(api) {\n  return (0, _util.memo)((era, withActive) => {\n    const cacheKey = `${CACHE_KEY}-${era.toString()}`;\n    const cached = withActive ? undefined : _util.deriveCache.get(cacheKey);\n    return cached ? (0, _rxjs.of)(cached) : api.query.staking.erasStakersClipped.entries(era).pipe((0, _operators.map)(stakers => {\n      const value = mapStakers(era, stakers);\n      !withActive && _util.deriveCache.set(cacheKey, value);\n      return value;\n    }));\n  });\n}\n\nfunction eraExposure(api) {\n  return (0, _util.memo)(era => api.derive.staking._eraExposure(era, true));\n}\n\nfunction _erasExposure(api) {\n  return (0, _util.memo)((eras, withActive) => eras.length ? (0, _rxjs.combineLatest)(eras.map(era => api.derive.staking._eraExposure(era, withActive))) : (0, _rxjs.of)([]));\n}\n\nfunction erasExposure(api) {\n  return (0, _util.memo)((withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._erasExposure(eras, withActive))));\n}","map":null,"metadata":{},"sourceType":"script"}