{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createClass;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _util2 = require(\"../util\");\n\nvar _Result = _interopRequireDefault(require(\"./Result\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction createClass({\n  api,\n  apiType,\n  decorateMethod\n}) {\n  var _temp, _ignoreStatusCb, _makeEraOptions, _makeSignOptions, _makeSignAndSendOptions, _observeSign, _observeStatus, _observeSend, _observeSubscribe, _optionsOrNonce, _signViaSigner, _updateSigner; // an instance of the base extrinsic for us to extend\n\n\n  const ExtrinsicBase = api.registry.createClass('Extrinsic');\n  return _temp = class Submittable extends ExtrinsicBase {\n    constructor(registry, extrinsic) {\n      super(registry, extrinsic, {\n        version: api.extrinsicType\n      });\n      Object.defineProperty(this, _ignoreStatusCb, {\n        writable: true,\n        value: void 0\n      });\n      Object.defineProperty(this, _makeEraOptions, {\n        writable: true,\n        value: (options, {\n          header,\n          mortalLength,\n          nonce\n        }) => {\n          if (!header) {\n            if ((0, _util.isNumber)(options.era)) {\n              // since we have no header, it is immortal, remove any option overrides\n              // so we only supply the genesisHash and no era to the construction\n              delete options.era;\n              delete options.blockHash;\n            }\n\n            return (0, _classPrivateFieldLooseBase2.default)(this, _makeSignOptions)[_makeSignOptions](options, {\n              nonce\n            });\n          }\n\n          return (0, _classPrivateFieldLooseBase2.default)(this, _makeSignOptions)[_makeSignOptions](options, {\n            blockHash: header.hash,\n            era: this.registry.createType('ExtrinsicEra', {\n              current: header.number,\n              period: options.era || mortalLength\n            }),\n            nonce\n          });\n        }\n      });\n      Object.defineProperty(this, _makeSignOptions, {\n        writable: true,\n        value: (options, extras) => {\n          return _objectSpread(_objectSpread(_objectSpread({\n            blockHash: api.genesisHash,\n            genesisHash: api.genesisHash\n          }, options), extras), {}, {\n            runtimeVersion: api.runtimeVersion,\n            signedExtensions: api.registry.signedExtensions,\n            version: api.extrinsicType\n          });\n        }\n      });\n      Object.defineProperty(this, _makeSignAndSendOptions, {\n        writable: true,\n        value: (optionsOrStatus, statusCb) => {\n          let options = {};\n\n          if ((0, _util.isFunction)(optionsOrStatus)) {\n            statusCb = optionsOrStatus;\n          } else {\n            options = _objectSpread({}, optionsOrStatus);\n          }\n\n          return [options, statusCb];\n        }\n      });\n      Object.defineProperty(this, _observeSign, {\n        writable: true,\n        value: (account, optionsOrNonce) => {\n          const address = (0, _util2.isKeyringPair)(account) ? account.address : account.toString();\n\n          const options = (0, _classPrivateFieldLooseBase2.default)(this, _optionsOrNonce)[_optionsOrNonce](optionsOrNonce);\n\n          let updateId;\n          return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe((0, _operators.first)(), (0, _operators.mergeMap)(async signingInfo => {\n            const eraOptions = (0, _classPrivateFieldLooseBase2.default)(this, _makeEraOptions)[_makeEraOptions](options, signingInfo);\n\n            if ((0, _util2.isKeyringPair)(account)) {\n              this.sign(account, eraOptions);\n            } else {\n              updateId = await (0, _classPrivateFieldLooseBase2.default)(this, _signViaSigner)[_signViaSigner](address, eraOptions, signingInfo.header);\n            }\n          }), (0, _operators.mapTo)(updateId));\n        }\n      });\n      Object.defineProperty(this, _observeStatus, {\n        writable: true,\n        value: (hash, status) => {\n          if (!status.isFinalized && !status.isInBlock) {\n            return (0, _rxjs.of)(new _Result.default({\n              status\n            }));\n          }\n\n          const blockHash = status.isInBlock ? status.asInBlock : status.asFinalized;\n          return api.derive.tx.events(blockHash).pipe((0, _operators.map)(({\n            block,\n            events\n          }) => new _Result.default({\n            events: (0, _util2.filterEvents)(hash, block, events, status),\n            status\n          })));\n        }\n      });\n      Object.defineProperty(this, _observeSend, {\n        writable: true,\n        value: (updateId = -1) => {\n          return api.rpc.author.submitExtrinsic(this).pipe((0, _operators.tap)(hash => {\n            (0, _classPrivateFieldLooseBase2.default)(this, _updateSigner)[_updateSigner](updateId, hash);\n          }));\n        }\n      });\n      Object.defineProperty(this, _observeSubscribe, {\n        writable: true,\n        value: (updateId = -1) => {\n          const hash = this.hash;\n          return api.rpc.author.submitAndWatchExtrinsic(this).pipe((0, _operators.switchMap)(status => (0, _classPrivateFieldLooseBase2.default)(this, _observeStatus)[_observeStatus](hash, status)), (0, _operators.tap)(status => {\n            (0, _classPrivateFieldLooseBase2.default)(this, _updateSigner)[_updateSigner](updateId, status);\n          }));\n        }\n      });\n      Object.defineProperty(this, _optionsOrNonce, {\n        writable: true,\n        value: (optionsOrNonce = {}) => {\n          return (0, _util.isBn)(optionsOrNonce) || (0, _util.isNumber)(optionsOrNonce) ? {\n            nonce: optionsOrNonce\n          } : optionsOrNonce;\n        }\n      });\n      Object.defineProperty(this, _signViaSigner, {\n        writable: true,\n        value: async (address, options, header) => {\n          const signer = options.signer || api.signer;\n          (0, _util.assert)(signer, 'No signer specified, either via api.setSigner or via sign options');\n          const payload = this.registry.createType('SignerPayload', _objectSpread(_objectSpread({}, options), {}, {\n            address,\n            blockNumber: header ? header.number : 0,\n            method: this.method\n          }));\n          let result;\n\n          if (signer.signPayload) {\n            result = await signer.signPayload(payload.toPayload());\n          } else if (signer.signRaw) {\n            result = await signer.signRaw(payload.toRaw());\n          } else {\n            throw new Error('Invalid signer interface, it should implement either signPayload or signRaw (or both)');\n          } // Here we explicitly call `toPayload()` again instead of working with an object\n          // (reference) as passed to the signer. This means that we are sure that the\n          // payload data is not modified from our inputs, but the signer\n\n\n          super.addSignature(address, result.signature, payload.toPayload());\n          return result.id;\n        }\n      });\n      Object.defineProperty(this, _updateSigner, {\n        writable: true,\n        value: (updateId, status) => {\n          if (updateId !== -1 && api.signer && api.signer.update) {\n            api.signer.update(updateId, status);\n          }\n        }\n      });\n      (0, _classPrivateFieldLooseBase2.default)(this, _ignoreStatusCb)[_ignoreStatusCb] = apiType === 'rxjs';\n    } // calculate the payment info for this transaction (if signed and submitted)\n\n\n    paymentInfo(account, options) {\n      const [allOptions] = (0, _classPrivateFieldLooseBase2.default)(this, _makeSignAndSendOptions)[_makeSignAndSendOptions](options);\n\n      const address = (0, _util2.isKeyringPair)(account) ? account.address : account.toString(); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n\n      return decorateMethod(() => api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe((0, _operators.first)(), (0, _operators.switchMap)(signingInfo => {\n        // setup our options (same way as in signAndSend)\n        const eraOptions = (0, _classPrivateFieldLooseBase2.default)(this, _makeEraOptions)[_makeEraOptions](allOptions, signingInfo);\n\n        const signOptions = (0, _classPrivateFieldLooseBase2.default)(this, _makeSignOptions)[_makeSignOptions](eraOptions, {}); // add a fake signature to the extrinsic\n\n\n        this.signFake(address, signOptions);\n        return api.rpc.payment.queryInfo(this.toHex());\n      })))();\n    } // sign a transaction, returning the this to allow chaining, i.e. .sign(...).send()\n\n\n    sign(account, optionsOrNonce) {\n      super.sign(account, (0, _classPrivateFieldLooseBase2.default)(this, _makeSignOptions)[_makeSignOptions]((0, _classPrivateFieldLooseBase2.default)(this, _optionsOrNonce)[_optionsOrNonce](optionsOrNonce), {}));\n      return this;\n    } // signs a transaction, returning `this` to allow chaining. E.g.: `sign(...).send()`\n    //\n    // also supports signing through external signers\n\n\n    signAsync(account, optionsOrNonce) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n      return decorateMethod(() => (0, _classPrivateFieldLooseBase2.default)(this, _observeSign)[_observeSign](account, optionsOrNonce).pipe((0, _operators.mapTo)(this)))();\n    } // signAndSend with an immediate Hash result\n    // signAndSend implementation for all 3 cases above\n\n\n    signAndSend(account, optionsOrStatus, optionalStatusCb) {\n      const [options, statusCb] = (0, _classPrivateFieldLooseBase2.default)(this, _makeSignAndSendOptions)[_makeSignAndSendOptions](optionsOrStatus, optionalStatusCb);\n\n      const isSubscription = api.hasSubscriptions && ((0, _classPrivateFieldLooseBase2.default)(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n\n      return decorateMethod(() => (0, _classPrivateFieldLooseBase2.default)(this, _observeSign)[_observeSign](account, options).pipe((0, _operators.switchMap)(updateId => isSubscription ? (0, _classPrivateFieldLooseBase2.default)(this, _observeSubscribe)[_observeSubscribe](updateId) : (0, _classPrivateFieldLooseBase2.default)(this, _observeSend)[_observeSend](updateId))) // FIXME This is wrong, SubmittableResult is _not_ a codec\n      )(statusCb);\n    } // send with an immediate Hash result\n    // send implementation for both immediate Hash and statusCb variants\n\n\n    send(statusCb) {\n      const isSubscription = api.hasSubscriptions && ((0, _classPrivateFieldLooseBase2.default)(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n\n      return decorateMethod(isSubscription ? (0, _classPrivateFieldLooseBase2.default)(this, _observeSubscribe)[_observeSubscribe] : (0, _classPrivateFieldLooseBase2.default)(this, _observeSend)[_observeSend])(statusCb);\n    }\n\n  }, _ignoreStatusCb = (0, _classPrivateFieldLooseKey2.default)(\"ignoreStatusCb\"), _makeEraOptions = (0, _classPrivateFieldLooseKey2.default)(\"makeEraOptions\"), _makeSignOptions = (0, _classPrivateFieldLooseKey2.default)(\"makeSignOptions\"), _makeSignAndSendOptions = (0, _classPrivateFieldLooseKey2.default)(\"makeSignAndSendOptions\"), _observeSign = (0, _classPrivateFieldLooseKey2.default)(\"observeSign\"), _observeStatus = (0, _classPrivateFieldLooseKey2.default)(\"observeStatus\"), _observeSend = (0, _classPrivateFieldLooseKey2.default)(\"observeSend\"), _observeSubscribe = (0, _classPrivateFieldLooseKey2.default)(\"observeSubscribe\"), _optionsOrNonce = (0, _classPrivateFieldLooseKey2.default)(\"optionsOrNonce\"), _signViaSigner = (0, _classPrivateFieldLooseKey2.default)(\"signViaSigner\"), _updateSigner = (0, _classPrivateFieldLooseKey2.default)(\"updateSigner\"), _temp;\n}","map":null,"metadata":{},"sourceType":"script"}