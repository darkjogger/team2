{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _types = require(\"@polkadot/types\");\n\nvar _Extrinsic = require(\"@polkadot/types/extrinsic/Extrinsic\");\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Decorate = _interopRequireDefault(require(\"./Decorate\")); // Copyright 2017-2020 @polkadot/api authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst KEEPALIVE_INTERVAL = 15000;\nconst l = (0, _util.logger)('api/init');\n\nclass Init extends _Decorate.default {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod);\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this.emit('connected');\n\n        this._isConnected.next(true);\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : (0, _utilCrypto.cryptoWaitReady)()]);\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n\n          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = setInterval(() => {\n            this._rpcCore.system.health().toPromise().catch(() => {// ignore\n            });\n          }, KEEPALIVE_INTERVAL);\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this.emit('disconnected');\n\n        this._isConnected.next(false);\n\n        if ((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]) {\n          clearInterval((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]);\n          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = null;\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n\n    if (!this.hasSubscriptions) {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // all injected types added to the registry for overrides\n\n\n    this.registry.setKnownTypes({\n      types: options.types,\n      typesAlias: options.typesAlias,\n      typesChain: options.typesChain,\n      typesSpec: options.typesSpec\n    }); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      this.registry.setKnownTypes(options.source.registry.knownTypes);\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n    this._queryMulti = this._decorateMulti(this._decorateMethod);\n    this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    this._rx.signer = options.signer;\n\n    this._rpcCore.provider.on('disconnected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n    this._rpcCore.provider.on('error', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderError)[_onProviderError]);\n\n    this._rpcCore.provider.on('connected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]); // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected()) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n\n  async _loadMeta() {\n    var _this$_options$source;\n\n    const genesisHash = await this._rpcCore.chain.getBlockHash(0).toPromise(); // on re-connection to the same chain, we don't want to re-do everything from chain again\n\n    if (this._isReady && !this._options.source && genesisHash.eq(this._genesisHash)) {\n      return true;\n    }\n\n    if (this._genesisHash) {\n      l.warn('Connection to new genesis detected, re-initializing');\n    }\n\n    this._genesisHash = genesisHash;\n\n    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub]) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub].unsubscribe();\n    }\n\n    const {\n      metadata = {}\n    } = this._options; // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n    this._runtimeMetadata = ((_this$_options$source = this._options.source) === null || _this$_options$source === void 0 ? void 0 : _this$_options$source._isReady) ? await this._metaFromSource(this._options.source) : await this._metaFromChain(metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeVersion = source.runtimeVersion;\n    this._genesisHash = source.genesisHash;\n    this.registry.setChainProperties(source.registry.getChainProperties());\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpcMethods(methods);\n\n    return source.runtimeMetadata;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, _operators.switchMap)(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        ((_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specVersion.eq(version.specVersion)) ? (0, _rxjs.of)(false) : this._rpcCore.state.getMetadata().pipe((0, _operators.map)(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version;\n          this.registerTypes((0, _typesKnown.getSpecTypes)(this.registry, this._runtimeChain, version.specName, version.specVersion));\n          this.injectMetadata(metadata, false);\n          return true;\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    var _this$_genesisHash;\n\n    const [runtimeVersion, chain, chainProps] = await Promise.all([this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise()]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // do the setup for the specific chain\n\n    this.registry.setChainProperties(chainProps);\n    this.registerTypes((0, _typesKnown.getSpecTypes)(this.registry, chain, runtimeVersion.specName, runtimeVersion.specVersion));\n\n    this._subscribeUpdates(); // filter the RPC methods (this does an rpc-methods call)\n\n\n    await this._filterRpc(); // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${((_this$_genesisHash = this._genesisHash) === null || _this$_genesisHash === void 0 ? void 0 : _this$_genesisHash.toHex()) || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = metadataKey in optMetadata ? new _types.Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise(); // get unique types & validate\n\n    metadata.getUniqTypes(false);\n    return metadata;\n  }\n\n  async _initFromMeta(metadata) {\n    // inject types based on metadata, if applicable\n    this.registerTypes((0, _typesKnown.getMetadataTypes)(this.registry, metadata.version));\n    const metaExtrinsic = metadata.asLatest.extrinsic; // only inject if we are not a clone (global init)\n\n    if (metaExtrinsic.version.gtn(0)) {\n      this._extrinsicType = metaExtrinsic.version.toNumber();\n    } else if (!this._options.source) {\n      // detect the extrinsic version in-use based on the last block\n      const {\n        block: {\n          extrinsics: [firstTx]\n        }\n      } = await this._rpcCore.chain.getBlock().toPromise(); // If we haven't sync-ed to 1 yes, this won't have any values\n\n      this._extrinsicType = firstTx ? firstTx.type : _Extrinsic.LATEST_EXTRINSIC_VERSION;\n    }\n\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion;\n    this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n\n}\n\nexports.default = Init;\n\nvar _healthTimer = (0, _classPrivateFieldLooseKey2.default)(\"healthTimer\");\n\nvar _updateSub = (0, _classPrivateFieldLooseKey2.default)(\"updateSub\");\n\nvar _onProviderConnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderConnect\");\n\nvar _onProviderDisconnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderDisconnect\");\n\nvar _onProviderError = (0, _classPrivateFieldLooseKey2.default)(\"onProviderError\");","map":null,"metadata":{},"sourceType":"script"}