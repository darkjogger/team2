{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _definitions = _interopRequireDefault(require(\"@polkadot/types/interfaces/runtime/definitions\"));\n\nvar _types = require(\"@polkadot/types\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // We can ignore the properties, added via Struct.with\n\n\nconst _Header = _types.Struct.with(_definitions.default.types.Header);\n/**\n * @name HeaderExtended\n * @description\n * A [[Block]] header with an additional `author` field that indicates the block author\n */\n\n\nclass HeaderExtended extends _Header {\n  constructor(registry, header, sessionValidators) {\n    super(registry, header);\n    Object.defineProperty(this, _author, {\n      writable: true,\n      value: void 0\n    });\n    (0, _classPrivateFieldLooseBase2.default)(this, _author)[_author] = this._extractAuthor(sessionValidators);\n  }\n\n  _extractAuthor(sessionValidators = []) {\n    const [pitem] = this.digest.logs.filter(({\n      type\n    }) => type === 'PreRuntime'); // extract from the substrate 2.0 PreRuntime digest\n\n    if (pitem) {\n      const [engine, data] = pitem.asPreRuntime;\n      return engine.extractAuthor(data, sessionValidators);\n    } else {\n      const [citem] = this.digest.logs.filter(({\n        type\n      }) => type === 'Consensus'); // extract author from the consensus (substrate 1.0, digest)\n\n      if (citem) {\n        const [engine, data] = citem.asConsensus;\n        return engine.extractAuthor(data, sessionValidators);\n      }\n    }\n\n    return undefined;\n  }\n  /**\n   * @description Convenience method, returns the author for the block\n   */\n\n\n  get author() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _author)[_author];\n  }\n  /**\n   * @description Creates a human-friendly JSON representation\n   */\n\n\n  toHuman(isExtended) {\n    return _objectSpread(_objectSpread({}, super.toHuman(isExtended)), {}, {\n      author: this.author ? this.author.toHuman() : undefined\n    });\n  }\n  /**\n   * @description Creates the JSON representation\n   */\n\n\n  toJSON() {\n    return _objectSpread(_objectSpread({}, super.toJSON()), {}, {\n      author: this.author ? this.author.toJSON() : undefined\n    });\n  }\n\n}\n\nexports.default = HeaderExtended;\n\nvar _author = (0, _classPrivateFieldLooseKey2.default)(\"author\");","map":null,"metadata":{},"sourceType":"script"}