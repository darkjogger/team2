{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.all = all;\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _util2 = require(\"../util\"); // Copyright 2017-2020 @polkadot/api-derive authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nfunction calcBalances(api, [{\n  accountId,\n  accountNonce,\n  freeBalance,\n  frozenFee,\n  frozenMisc,\n  reservedBalance,\n  votingBalance\n}, bestNumber, [vesting, locks]]) {\n  let lockedBalance = api.registry.createType('Balance');\n  let lockedBreakdown = [];\n  let allLocked = false;\n\n  if (Array.isArray(locks)) {\n    // only get the locks that are valid until passed the current block\n    lockedBreakdown = locks.filter(({\n      until\n    }) => !until || bestNumber && until.gt(bestNumber));\n    const notAll = lockedBreakdown.filter(({\n      amount\n    }) => !amount.isMax());\n    allLocked = lockedBreakdown.some(({\n      amount\n    }) => amount.isMax()); // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699\n\n    if (notAll.length) {\n      lockedBalance = api.registry.createType('Balance', (0, _util.bnMax)(...notAll.map(({\n        amount\n      }) => amount)));\n    }\n  } // Calculate the vesting balances,\n  //  - offset = balance locked at startingBlock\n  //  - perBlock is the unlock amount\n\n\n  const {\n    locked: vestingTotal,\n    perBlock,\n    startingBlock\n  } = vesting || api.registry.createType('VestingInfo');\n  const isStarted = bestNumber.gt(startingBlock);\n  const vestedBalance = api.registry.createType('Balance', isStarted ? perBlock.mul(bestNumber.sub(startingBlock)) : 0);\n  const isVesting = isStarted && vestedBalance.lt(vestingTotal); // The available balance & vested has an interplay here\n  // \"\n  // vesting is a guarantee that the account's balance will never go below a certain amount. so it functions in the opposite way, a bit like a lock that is monotonically decreasing rather than a liquid amount that is monotonically increasing.\n  // locks function as the same guarantee - that a balance will not be lower than a particular amount.\n  // because of this you can see that if there is a \"vesting lock\" that guarantees the balance cannot go below 200, and a \"staking lock\" that guarantees the balance cannot drop below 300, then we just have two guarantees of which the first is irrelevant.\n  // i.e. (balance >= 200 && balance >= 300) == (balance >= 300)\n  // \"\"\n\n  const floating = freeBalance.sub(lockedBalance);\n  const extraReceived = isVesting ? freeBalance.sub(vestingTotal) : new _bn.default(0);\n  const availableBalance = api.registry.createType('Balance', allLocked ? 0 : (0, _util.bnMax)(new _bn.default(0), isVesting && floating.gt(vestedBalance) ? vestedBalance.add(extraReceived) : floating));\n  return {\n    accountId,\n    accountNonce,\n    availableBalance,\n    freeBalance,\n    frozenFee,\n    frozenMisc,\n    isVesting,\n    lockedBalance,\n    lockedBreakdown,\n    reservedBalance,\n    vestedBalance,\n    vestingTotal,\n    votingBalance\n  };\n} // old\n\n\nfunction queryOld(api, accountId) {\n  return api.queryMulti([[api.query.balances.locks, accountId], [api.query.balances.vesting, accountId]]).pipe((0, _operators.map)(([locks, optVesting]) => {\n    let vestingNew = null;\n\n    if (optVesting.isSome) {\n      const {\n        offset: locked,\n        perBlock,\n        startingBlock\n      } = optVesting.unwrap();\n      vestingNew = api.registry.createType('VestingInfo', {\n        locked,\n        perBlock,\n        startingBlock\n      });\n    }\n\n    return [vestingNew, locks];\n  }));\n} // current (balances  vesting)\n\n\nfunction queryCurrent(api, accountId) {\n  var _api$query$vesting;\n\n  return (((_api$query$vesting = api.query.vesting) === null || _api$query$vesting === void 0 ? void 0 : _api$query$vesting.vesting) ? api.queryMulti([[api.query.balances.locks, accountId], [api.query.vesting.vesting, accountId]]) : api.query.balances.locks(accountId).pipe((0, _operators.map)(locks => [locks, api.registry.createType('Option<VestingInfo>')]))).pipe((0, _operators.map)(([locks, optVesting]) => [optVesting.unwrapOr(null), locks]));\n}\n/**\n * @name all\n * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.\n * @returns An object containing the results of various balance queries\n * @example\n * <BR>\n *\n * ```javascript\n * const ALICE = 'F7Hs';\n *\n * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {\n *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);\n * });\n * ```\n */\n\n\nfunction all(api) {\n  return (0, _util2.memo)(address => api.derive.balances.account(address).pipe((0, _operators.switchMap)(account => !account.accountId.isEmpty ? (0, _rxjs.combineLatest)([(0, _rxjs.of)(account), api.derive.chain.bestNumber(), (0, _util.isFunction)(api.query.balances.account) ? queryCurrent(api, account.accountId) : queryOld(api, account.accountId)]) : (0, _rxjs.of)([account, api.registry.createType('BlockNumber'), [null, api.registry.createType('Vec<BalanceLock>')]])), (0, _operators.map)(result => calcBalances(api, result))));\n}","map":null,"metadata":{},"sourceType":"script"}