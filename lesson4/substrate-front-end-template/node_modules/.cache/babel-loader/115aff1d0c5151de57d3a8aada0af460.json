{"ast":null,"code":"const crypto = require('crypto');\n\nlet wasm;\nconst requires = {\n  crypto\n};\nlet cachegetUint8Memory = null;\n\nfunction getUint8Memory() {\n  if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {\n    cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);\n  }\n\n  return cachegetUint8Memory;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm(arg) {\n  const ptr = wasm.__wbindgen_malloc(arg.length * 1);\n\n  getUint8Memory().set(arg, ptr / 1);\n  WASM_VECTOR_LEN = arg.length;\n  return ptr;\n}\n\nfunction getArrayU8FromWasm(ptr, len) {\n  return getUint8Memory().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedGlobalArgumentPtr = null;\n\nfunction globalArgumentPtr() {\n  if (cachedGlobalArgumentPtr === null) {\n    cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr();\n  }\n\n  return cachedGlobalArgumentPtr;\n}\n\nlet cachegetUint32Memory = null;\n\nfunction getUint32Memory() {\n  if (cachegetUint32Memory === null || cachegetUint32Memory.buffer !== wasm.memory.buffer) {\n    cachegetUint32Memory = new Uint32Array(wasm.memory.buffer);\n  }\n\n  return cachegetUint32Memory;\n}\n/**\n* Perform a derivation on a secret\n*\n* * secret: UIntArray with 64 bytes\n* * cc: UIntArray with 32 bytes\n*\n* returned vector the derived keypair as a array of 96 bytes\n* @param {Uint8Array} arg0\n* @param {Uint8Array} arg1\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_sr_derive_keypair_hard = function (arg0, arg1) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passArray8ToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_sr_derive_keypair_hard(retptr, ptr0, len0, ptr1, len1);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n  }\n};\n/**\n* Perform a derivation on a secret\n*\n* * secret: UIntArray with 64 bytes\n* * cc: UIntArray with 32 bytes\n*\n* returned vector the derived keypair as a array of 96 bytes\n* @param {Uint8Array} arg0\n* @param {Uint8Array} arg1\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_sr_derive_keypair_soft = function (arg0, arg1) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passArray8ToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_sr_derive_keypair_soft(retptr, ptr0, len0, ptr1, len1);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n  }\n};\n/**\n* Perform a derivation on a publicKey\n*\n* * pubkey: UIntArray with 32 bytes\n* * cc: UIntArray with 32 bytes\n*\n* returned vector is the derived publicKey as a array of 32 bytes\n* @param {Uint8Array} arg0\n* @param {Uint8Array} arg1\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_sr_derive_public_soft = function (arg0, arg1) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passArray8ToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_sr_derive_public_soft(retptr, ptr0, len0, ptr1, len1);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n  }\n};\n/**\n* Generate a key pair.\n*\n* * seed: UIntArray with 32 element\n*\n* returned vector is the concatenation of first the private key (64 bytes)\n* followed by the public key (32) bytes.\n* @param {Uint8Array} arg0\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_sr_from_seed = function (arg0) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_sr_from_seed(retptr, ptr0, len0);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n  }\n};\n/**\n* Sign a message\n*\n* The combination of both public and private key must be provided.\n* This is effectively equivalent to a keypair.\n*\n* * public: UIntArray with 32 element\n* * private: UIntArray with 64 element\n* * message: Arbitrary length UIntArray\n*\n* * returned vector is the signature consisting of 64 bytes.\n* @param {Uint8Array} arg0\n* @param {Uint8Array} arg1\n* @param {Uint8Array} arg2\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_sr_sign = function (arg0, arg1, arg2) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passArray8ToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const ptr2 = passArray8ToWasm(arg2);\n  const len2 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_sr_sign(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    wasm.__wbindgen_free(ptr2, len2 * 1);\n  }\n};\n/**\n* Verify a message and its corresponding against a public key;\n*\n* * signature: UIntArray with 64 element\n* * message: Arbitrary length UIntArray\n* * pubkey: UIntArray with 32 element\n* @param {Uint8Array} arg0\n* @param {Uint8Array} arg1\n* @param {Uint8Array} arg2\n* @returns {boolean}\n*/\n\n\nmodule.exports.ext_sr_verify = function (arg0, arg1, arg2) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passArray8ToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const ptr2 = passArray8ToWasm(arg2);\n  const len2 = WASM_VECTOR_LEN;\n\n  try {\n    return wasm.ext_sr_verify(ptr0, len0, ptr1, len1, ptr2, len2) !== 0;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    wasm.__wbindgen_free(ptr2, len2 * 1);\n  }\n};\n/**\n* blake2b hash for the specified input\n*\n* * data: Arbitrary data to be hashed\n* * key: Key to add to the hashing (normally empty)\n* * size: Size in bytes of the resulting output\n*\n* Returns a vector with the hash result\n* @param {Uint8Array} arg0\n* @param {Uint8Array} arg1\n* @param {number} arg2\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_blake2b = function (arg0, arg1, arg2) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passArray8ToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_blake2b(retptr, ptr0, len0, ptr1, len1, arg2);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n  }\n};\n/**\n* Create a keccak256 hash for the specified input\n*\n*\n* Returns the hash as a vector\n* @param {Uint8Array} arg0\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_keccak256 = function (arg0) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_keccak256(retptr, ptr0, len0);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n  }\n};\n/**\n* pbkdf2 hash from an input, salt for the number of specified rounds\n*\n* * data: Arbitrary data to be hashed\n* * salt: Salt for this hash\n* * rounds: The number of rounds to perform\n*\n* Returns a vecor with the hash result\n* @param {Uint8Array} arg0\n* @param {Uint8Array} arg1\n* @param {number} arg2\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_pbkdf2 = function (arg0, arg1, arg2) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passArray8ToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_pbkdf2(retptr, ptr0, len0, ptr1, len1, arg2);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n  }\n};\n/**\n* sha512 hash for the specified input\n*\n* * data: Arbitrary data to be hashed\n*\n* Returns a vecor with the hash result\n* @param {Uint8Array} arg0\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_sha512 = function (arg0) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_sha512(retptr, ptr0, len0);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n  }\n};\n/**\n* twox hash for the specified input and rounds\n*\n* * data: Arbitrary data to be hashed\n* * rounds: Number of 8-byte rounds to add to the output\n*\n* Returns a vecor with the hash result\n* @param {Uint8Array} arg0\n* @param {number} arg1\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_twox = function (arg0, arg1) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_twox(retptr, ptr0, len0, arg1);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n  }\n};\n\nconst {\n  u8aToString\n} = require('@polkadot/util'); // let cachedTextDecoder = new TextDecoder('utf-8');\n\n\nfunction getStringFromWasm(ptr, len) {\n  return u8aToString(getUint8Memory().subarray(ptr, ptr + len));\n}\n/**\n* Generate a bip39 phrase\n*\n* words: number of words, either 12, 15, 18 21 or 24\n*\n* Returns the bip 39 phrase\n* @param {number} arg0\n* @returns {string}\n*/\n\n\nmodule.exports.ext_bip39_generate = function (arg0) {\n  const retptr = globalArgumentPtr();\n  wasm.ext_bip39_generate(retptr, arg0);\n  const mem = getUint32Memory();\n  const rustptr = mem[retptr / 4];\n  const rustlen = mem[retptr / 4 + 1];\n  const realRet = getStringFromWasm(rustptr, rustlen).slice();\n\n  wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n  return realRet;\n};\n\nconst {\n  stringToU8a\n} = require('@polkadot/util'); // let cachedTextEncoder = new TextEncoder('utf-8');\n\n\nlet passStringToWasm;\n\nif (typeof stringToU8aInto === 'function') {\n  passStringToWasm = function (arg) {\n    let size = arg.length;\n\n    let ptr = wasm.__wbindgen_malloc(size);\n\n    let writeOffset = 0;\n\n    while (true) {\n      const view = getUint8Memory().subarray(ptr + writeOffset, ptr + size);\n      const {\n        read,\n        written\n      } = stringToU8aInto(arg, view);\n      arg = arg.substring(read);\n      writeOffset += written;\n\n      if (arg.length === 0) {\n        break;\n      }\n\n      ptr = wasm.__wbindgen_realloc(ptr, size, size * 2);\n      size *= 2;\n    }\n\n    WASM_VECTOR_LEN = writeOffset;\n    return ptr;\n  };\n} else {\n  passStringToWasm = function (arg) {\n    const buf = stringToU8a(arg);\n\n    const ptr = wasm.__wbindgen_malloc(buf.length);\n\n    getUint8Memory().set(buf, ptr);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr;\n  };\n}\n/**\n* Create entropy from a bip39 phrase\n*\n* * phrase: mnemonic phrase\n*\n* Returns the entropy\n* @param {string} arg0\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_bip39_to_entropy = function (arg0) {\n  const ptr0 = passStringToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_bip39_to_entropy(retptr, ptr0, len0);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n  }\n};\n/**\n* Create a mini-secret from a bip39 phrase\n*\n* * phrase: mnemonic phrase\n*\n* Returns the 32-byte mini-secret via entropy\n* @param {string} arg0\n* @param {string} arg1\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_bip39_to_mini_secret = function (arg0, arg1) {\n  const ptr0 = passStringToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passStringToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_bip39_to_mini_secret(retptr, ptr0, len0, ptr1, len1);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n  }\n};\n/**\n* Creates a see from a bip-39 phrase\n*\n* @phrase: mnemonic phrase\n*\n* Returns a 32-byte seed\n* @param {string} arg0\n* @param {string} arg1\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_bip39_to_seed = function (arg0, arg1) {\n  const ptr0 = passStringToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passStringToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_bip39_to_seed(retptr, ptr0, len0, ptr1, len1);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n  }\n};\n/**\n* Validates a bip39 phrase\n*\n* * phrase: mnemonic phrase\n*\n* Returns the true/false\n* @param {string} arg0\n* @returns {boolean}\n*/\n\n\nmodule.exports.ext_bip39_validate = function (arg0) {\n  const ptr0 = passStringToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n\n  try {\n    return wasm.ext_bip39_validate(ptr0, len0) !== 0;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n  }\n};\n/**\n* Generate a key pair.\n*\n* * seed: UIntArray with 32 element\n*\n* returned vector is the concatenation of first the private key (64 bytes)\n* followed by the public key (32) bytes.\n* @param {Uint8Array} arg0\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_ed_from_seed = function (arg0) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_ed_from_seed(retptr, ptr0, len0);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n  }\n};\n/**\n* Sign a message\n*\n* The combination of both public and private key must be provided.\n* This is effectively equivalent to a keypair.\n*\n* * public: UIntArray with 32 element\n* * private: UIntArray with 64 element\n* * message: Arbitrary length UIntArray\n*\n* * returned vector is the signature consisting of 64 bytes.\n* @param {Uint8Array} arg0\n* @param {Uint8Array} arg1\n* @param {Uint8Array} arg2\n* @returns {Uint8Array}\n*/\n\n\nmodule.exports.ext_ed_sign = function (arg0, arg1, arg2) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passArray8ToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const ptr2 = passArray8ToWasm(arg2);\n  const len2 = WASM_VECTOR_LEN;\n  const retptr = globalArgumentPtr();\n\n  try {\n    wasm.ext_ed_sign(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n\n    return realRet;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    wasm.__wbindgen_free(ptr2, len2 * 1);\n  }\n};\n/**\n* Verify a message and its corresponding against a public key;\n*\n* * signature: UIntArray with 64 element\n* * message: Arbitrary length UIntArray\n* * pubkey: UIntArray with 32 element\n* @param {Uint8Array} arg0\n* @param {Uint8Array} arg1\n* @param {Uint8Array} arg2\n* @returns {boolean}\n*/\n\n\nmodule.exports.ext_ed_verify = function (arg0, arg1, arg2) {\n  const ptr0 = passArray8ToWasm(arg0);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passArray8ToWasm(arg1);\n  const len1 = WASM_VECTOR_LEN;\n  const ptr2 = passArray8ToWasm(arg2);\n  const len2 = WASM_VECTOR_LEN;\n\n  try {\n    return wasm.ext_ed_verify(ptr0, len0, ptr1, len1, ptr2, len2) !== 0;\n  } finally {\n    wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    wasm.__wbindgen_free(ptr2, len2 * 1);\n  }\n};\n\nconst heap = new Array(32);\nheap.fill(undefined);\nheap.push(undefined, null, true, false);\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n  if (heap_next === heap.length) heap.push(heap.length + 1);\n  const idx = heap_next;\n  heap_next = heap[idx];\n  heap[idx] = obj;\n  return idx;\n}\n\nmodule.exports.__wbg_new_3a746f2619705add = function (arg0, arg1) {\n  let varg0 = getStringFromWasm(arg0, arg1);\n  return addHeapObject(new Function(varg0));\n};\n\nfunction getObject(idx) {\n  return heap[idx];\n}\n\nmodule.exports.__wbg_call_f54d3a6dadb199ca = function (arg0, arg1) {\n  return addHeapObject(getObject(arg0).call(getObject(arg1)));\n};\n\nmodule.exports.__wbg_self_ac379e780a0d8b94 = function (arg0) {\n  return addHeapObject(getObject(arg0).self);\n};\n\nmodule.exports.__wbg_crypto_1e4302b85d4f64a2 = function (arg0) {\n  return addHeapObject(getObject(arg0).crypto);\n};\n\nmodule.exports.__wbg_getRandomValues_1b4ba144162a5c9e = function (arg0) {\n  return addHeapObject(getObject(arg0).getRandomValues);\n};\n\nmodule.exports.__wbg_getRandomValues_1ef11e888e5228e9 = function (arg0, arg1, arg2) {\n  let varg1 = getArrayU8FromWasm(arg1, arg2);\n  getObject(arg0).getRandomValues(varg1);\n};\n\nmodule.exports.__wbg_require_6461b1e9a0d7c34a = function (arg0, arg1) {\n  let varg0 = getStringFromWasm(arg0, arg1);\n  return addHeapObject(requires[varg0]);\n};\n\nmodule.exports.__wbg_randomFillSync_1b52c8482374c55b = function (arg0, arg1, arg2) {\n  let varg1 = getArrayU8FromWasm(arg1, arg2);\n  getObject(arg0).randomFillSync(varg1);\n};\n\nmodule.exports.__wbindgen_is_undefined = function (i) {\n  return getObject(i) === undefined ? 1 : 0;\n};\n\nmodule.exports.__wbindgen_jsval_eq = function (a, b) {\n  return getObject(a) === getObject(b) ? 1 : 0;\n};\n\nfunction dropObject(idx) {\n  if (idx < 36) return;\n  heap[idx] = heap_next;\n  heap_next = idx;\n}\n\nmodule.exports.__wbindgen_object_drop_ref = function (i) {\n  dropObject(i);\n}; // wasm = require('./wasm_bg');\n\n\nmodule.exports.abort = function () {\n  throw new Error('abort');\n};\n\nconst createPromise = require('./wasm_promise');\n\nconst wasmPromise = createPromise().catch(() => null);\n\nmodule.exports.isReady = function () {\n  return !!wasm;\n};\n\nmodule.exports.waitReady = function () {\n  return wasmPromise.then(() => !!wasm);\n};\n\nwasmPromise.then(_wasm => {\n  wasm = _wasm;\n});","map":null,"metadata":{},"sourceType":"script"}