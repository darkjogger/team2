{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _codec = require(\"@polkadot/types/codec\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst EMPTY_U8A = new Uint8Array([]);\n\nconst NULL_HASHER = value => value; // with the prefix, method & options, create both the string & raw keys\n\n/** @internal */\n\n\nfunction expandKey({\n  method,\n  prefix\n}, options) {\n  return options.key ? options.key : `${prefix} ${method}`;\n} // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers({\n  meta: {\n    type\n  }\n}) {\n  if (type.isDoubleMap) {\n    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [(0, _getHasher.default)(type.asMap.hasher)];\n  } // the default\n\n\n  return [(0, _getHasher.default)()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, stringKey, args, [hasher1, hasher2], metaVersion) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn; // since we are passing an almost-unknown through, trust, but verify\n\n  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues\n\n  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');\n  const [key1, key2] = args;\n  const map = type.asDoubleMap;\n  const val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();\n  const val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return _codec.Compact.addLengthPrefix(metaVersion <= 8 ? (0, _util.u8aConcat)(hasher1((0, _util.u8aConcat)((0, _util.stringToU8a)(stringKey), val1)), hasher2(val2)) : (0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, stringKey, arg, hasher, metaVersion) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn;\n  let param = EMPTY_U8A;\n\n  if (type.isMap) {\n    const map = type.asMap;\n    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), `${name.toString()} is a Map and requires one argument`);\n    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return _codec.Compact.addLengthPrefix(metaVersion <= 8 ? hasher((0, _util.u8aConcat)((0, _util.stringToU8a)(stringKey), param)) : (0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, storageFn) {\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('PlainTypeLatest', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  const prefixKey = registry.createType('StorageKey', iterFn, {\n    method,\n    section\n  });\n  return arg => !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {\n    method,\n    section\n  }) : prefixKey;\n} // attach the head key hashing for linked maps\n\n/** @internal */\n\n\nfunction extendLinkedMap(registry, itemFn, storageFn, stringKey, hasher, metaVersion) {\n  const key = metaVersion <= 8 ? hasher(`head of ${stringKey}`) : (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(itemFn.prefix, 128), (0, _utilCrypto.xxhashAsU8a)(`HeadOf${itemFn.method}`, 128));\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, () => new _codec.Raw(registry, key));\n  return storageFn;\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? new _codec.Raw(registry, (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a()))) : new _codec.Raw(registry, createPrefixedKey(itemFn)));\n  return storageFn;\n} // attach the full list hashing for double maps\n\n/** @internal */\n\n\nfunction extendDoubleMap(registry, itemFn, storageFn) {\n  return extendPrefixedMap(registry, itemFn, storageFn);\n}\n/** @internal */\n\n\nfunction createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const stringKey = expandKey(itemFn, options);\n  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n  const _storageFn = arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, stringKey, arg, [hasher, key2Hasher], options.metaVersion) : createKey(registry, itemFn, stringKey, arg, options.skipHashing ? NULL_HASHER : hasher, options.metaVersion);\n\n  const storageFn = expandWithMeta(itemFn, _storageFn);\n\n  if (type.isMap) {\n    const map = type.asMap;\n\n    if (map.linked.isTrue) {\n      extendLinkedMap(registry, itemFn, storageFn, stringKey, hasher, options.metaVersion);\n    } else {\n      extendPrefixedMap(registry, itemFn, storageFn);\n    }\n  } else if (type.isDoubleMap) {\n    extendDoubleMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];\n\n  return storageFn;\n}","map":null,"metadata":{},"sourceType":"script"}