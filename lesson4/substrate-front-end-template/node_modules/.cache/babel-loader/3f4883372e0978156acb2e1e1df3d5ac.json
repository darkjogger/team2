{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"LATEST_EXTRINSIC_VERSION\", {\n  enumerable: true,\n  get: function () {\n    return _Extrinsic.TRANSACTION_VERSION;\n  }\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Base = _interopRequireDefault(require(\"../codec/Base\"));\n\nvar _Compact = _interopRequireDefault(require(\"../codec/Compact\"));\n\nvar _constants = require(\"./constants\");\n\nvar _Extrinsic = require(\"./v4/Extrinsic\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst VERSIONS = ['ExtrinsicUnknown', // v0 is unknown\n'ExtrinsicV1', 'ExtrinsicV2', 'ExtrinsicV3', 'ExtrinsicV4'];\n\nclass ExtrinsicBase extends _Base.default {\n  /**\n   * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\n   */\n  get args() {\n    return this.method.args;\n  }\n  /**\n   * @description The argument definitions, compatible with [[Call]]\n   */\n\n\n  get argsDef() {\n    return this.method.argsDef;\n  }\n  /**\n   * @description The actual `[sectionIndex, methodIndex]` as used in the Call\n   */\n\n\n  get callIndex() {\n    return this.method.callIndex;\n  }\n  /**\n   * @description The actual data for the Call\n   */\n\n\n  get data() {\n    return this.method.data;\n  }\n  /**\n   * @description The era for this extrinsic\n   */\n\n\n  get era() {\n    return this._raw.signature.era;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description `true` is method has `Origin` argument (compatibility with [Call])\n   */\n\n\n  get hasOrigin() {\n    return this.method.hasOrigin;\n  }\n  /**\n   * @description `true` id the extrinsic is signed\n   */\n\n\n  get isSigned() {\n    return this._raw.signature.isSigned;\n  }\n  /**\n   * @description The length of the actual data, excluding prefix\n   */\n\n\n  get length() {\n    return this.toU8a(true).length;\n  }\n  /**\n   * @description The [[FunctionMetadataLatest]] that describes the extrinsic\n   */\n\n\n  get meta() {\n    return this.method.meta;\n  }\n  /**\n   * @description The [[Call]] this extrinsic wraps\n   */\n\n\n  get method() {\n    return this._raw.method;\n  }\n  /**\n   * @description The nonce for this extrinsic\n   */\n\n\n  get nonce() {\n    return this._raw.signature.nonce;\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n\n\n  get signature() {\n    return this._raw.signature.signature;\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n\n\n  get signer() {\n    return this._raw.signature.signer;\n  }\n  /**\n   * @description Forwards compat\n   */\n\n\n  get tip() {\n    return this._raw.signature.tip;\n  }\n  /**\n   * @description Returns the raw transaction version (not flagged with signing information)\n  */\n\n\n  get type() {\n    return this._raw.version;\n  }\n  /**\n   * @description Returns the encoded version flag\n  */\n\n\n  get version() {\n    return this.type | (this.isSigned ? _constants.BIT_SIGNED : _constants.BIT_UNSIGNED);\n  }\n\n}\n/**\n * @name GenericExtrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\n\n\nclass Extrinsic extends ExtrinsicBase {\n  constructor(registry, value, {\n    version\n  } = {}) {\n    super(registry, Extrinsic._decodeExtrinsic(registry, value, version));\n  }\n  /** @internal */\n\n\n  static _newFromValue(registry, value, version) {\n    if (value instanceof Extrinsic) {\n      return value._raw;\n    }\n\n    const isSigned = (version & _constants.BIT_SIGNED) === _constants.BIT_SIGNED;\n    const type = VERSIONS[version & _constants.UNMASK_VERSION] || VERSIONS[0]; // we cast here since the VERSION definition is incredibly broad - we don't have a\n    // slice for \"only add extrinsic types\", and more string definitions become unwieldy\n\n    return registry.createType(type, value, {\n      isSigned,\n      version\n    });\n  }\n  /** @internal */\n\n\n  static _decodeExtrinsic(registry, value, version = _constants.DEFAULT_VERSION) {\n    if ((0, _util.isU8a)(value) || Array.isArray(value) || (0, _util.isHex)(value)) {\n      return Extrinsic._decodeU8a(registry, (0, _util.u8aToU8a)(value), version);\n    } else if (value instanceof registry.createClass('Call')) {\n      return Extrinsic._newFromValue(registry, {\n        method: value\n      }, version);\n    }\n\n    return Extrinsic._newFromValue(registry, value, version);\n  }\n  /** @internal */\n\n\n  static _decodeU8a(registry, value, version) {\n    if (!value.length) {\n      return Extrinsic._newFromValue(registry, new Uint8Array(), version);\n    }\n\n    const [offset, length] = _Compact.default.decodeU8a(value);\n\n    const total = offset + length.toNumber();\n    (0, _util.assert)(total <= value.length, `Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);\n    const data = value.subarray(offset, total);\n    return Extrinsic._newFromValue(registry, data.subarray(1), data[0]);\n  }\n  /**\n   * @description Injects an already-generated signature into the extrinsic\n   */\n\n\n  addSignature(signer, signature, payload) {\n    this._raw.addSignature(signer, signature, payload);\n\n    return this;\n  }\n  /**\n   * @description Sign the extrinsic with a specific keypair\n   */\n\n\n  sign(account, options) {\n    this._raw.sign(account, options);\n\n    return this;\n  }\n  /**\n   * @describe Adds a fake signature to the extrinsic\n   */\n\n\n  signFake(signer, options) {\n    this._raw.signFake(signer, options);\n\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex(isBare) {\n    return (0, _util.u8aToHex)(this.toU8a(isBare));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    return _objectSpread({\n      isSigned: this.isSigned,\n      method: this.method.toHuman(isExpanded)\n    }, this.isSigned ? {\n      era: this.era.toHuman(isExpanded),\n      nonce: this.nonce.toHuman(isExpanded),\n      signature: this.signature.toHex(),\n      signer: this.signer.toHuman(isExpanded),\n      tip: this.tip.toHuman(isExpanded)\n    } : {});\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Extrinsic';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value is not length-prefixed\n   */\n\n\n  toU8a(isBare) {\n    // we do not apply bare to the internal values, rather this only determines out length addition,\n    // where we strip all lengths this creates an extrinsic that cannot be decoded\n    const encoded = (0, _util.u8aConcat)(new Uint8Array([this.version]), this._raw.toU8a());\n    return isBare ? encoded : _Compact.default.addLengthPrefix(encoded);\n  }\n\n}\n\nexports.default = Extrinsic;","map":null,"metadata":{},"sourceType":"script"}