{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createClass = createClass;\nexports.ClassOfUnsafe = ClassOfUnsafe;\nexports.ClassOf = ClassOf;\nexports.getTypeClass = getTypeClass;\n\nvar _types = require(\"./types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _BTreeMap = _interopRequireDefault(require(\"../codec/BTreeMap\"));\n\nvar _BTreeSet = _interopRequireDefault(require(\"../codec/BTreeSet\"));\n\nvar _Compact = _interopRequireDefault(require(\"../codec/Compact\"));\n\nvar _Enum = _interopRequireDefault(require(\"../codec/Enum\"));\n\nvar _HashMap = _interopRequireDefault(require(\"../codec/HashMap\"));\n\nvar _Int = _interopRequireDefault(require(\"../codec/Int\"));\n\nvar _Option = _interopRequireDefault(require(\"../codec/Option\"));\n\nvar _Result = _interopRequireDefault(require(\"../codec/Result\"));\n\nvar _Set = _interopRequireDefault(require(\"../codec/Set\"));\n\nvar _Struct = _interopRequireDefault(require(\"../codec/Struct\"));\n\nvar _Tuple = _interopRequireDefault(require(\"../codec/Tuple\"));\n\nvar _U8aFixed = _interopRequireDefault(require(\"../codec/U8aFixed\"));\n\nvar _UInt = _interopRequireDefault(require(\"../codec/UInt\"));\n\nvar _Vec = _interopRequireDefault(require(\"../codec/Vec\"));\n\nvar _VecFixed = _interopRequireDefault(require(\"../codec/VecFixed\"));\n\nvar _DoNotConstruct = _interopRequireDefault(require(\"../primitive/DoNotConstruct\"));\n\nvar _getTypeDef = require(\"./getTypeDef\"); // Copyright 2017-2020 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nfunction createClass(registry, type) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return getTypeClass(registry, (0, _getTypeDef.getTypeDef)(type));\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, if it cannot be parsed, it will yield\n// a runtime error.\n\n\nfunction ClassOfUnsafe(registry, name) {\n  return createClass(registry, name);\n} // alias for createClass\n\n\nfunction ClassOf(registry, name) {\n  // TS2589: Type instantiation is excessively deep and possibly infinite.\n  // The above happens with as Constructor<InterfaceTypes[K]>;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return ClassOfUnsafe(registry, name);\n}\n\nfunction getSubDefArray(value) {\n  (0, _util.assert)(value.sub && Array.isArray(value.sub), `Expected subtype as TypeDef[] in ${JSON.stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubDef(value) {\n  (0, _util.assert)(value.sub && !Array.isArray(value.sub), `Expected subtype as TypeDef in ${JSON.stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubType(value) {\n  return getSubDef(value).type;\n} // create a maps of type string constructors from the input\n\n\nfunction getTypeClassMap(value) {\n  const result = {};\n  return getSubDefArray(value).reduce((result, sub) => {\n    result[sub.name] = sub.type;\n    return result;\n  }, result);\n} // create an array of type string constructors from the input\n\n\nfunction getTypeClassArray(value) {\n  return getSubDefArray(value).map(({\n    type\n  }) => type);\n}\n\nfunction createInt({\n  displayName,\n  length\n}, Clazz) {\n  (0, _util.assert)((0, _util.isNumber)(length), `Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);\n  return Clazz.with(length, displayName);\n}\n\nfunction createHashMap(value, Clazz) {\n  const [keyType, valueType] = getTypeClassArray(value);\n  return Clazz.with(keyType, valueType);\n}\n\nconst infoMapping = {\n  [_types.TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(value, _BTreeMap.default),\n  [_types.TypeDefInfo.BTreeSet]: (registry, value) => _BTreeSet.default.with(getSubType(value)),\n  [_types.TypeDefInfo.Compact]: (registry, value) => _Compact.default.with(getSubType(value)),\n  [_types.TypeDefInfo.DoNotConstruct]: (registry, value) => _DoNotConstruct.default.with(value.displayName),\n  [_types.TypeDefInfo.Enum]: (registry, value) => _Enum.default.with(getTypeClassMap(value)),\n  [_types.TypeDefInfo.HashMap]: (registry, value) => createHashMap(value, _HashMap.default),\n  [_types.TypeDefInfo.Int]: (registry, value) => createInt(value, _Int.default),\n  // We have circular deps between Linkage & Struct\n  [_types.TypeDefInfo.Linkage]: (registry, value) => {\n    const type = `Option<${getSubType(value)}>`; // eslint-disable-next-line sort-keys\n\n    const Clazz = _Struct.default.with({\n      previous: type,\n      next: type\n    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n\n    ClassOf.prototype.toRawType = function () {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n      return `Linkage<${this.next.toRawType(true)}>`;\n    };\n\n    return Clazz;\n  },\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [_types.TypeDefInfo.Null]: (registry, _) => createClass(registry, 'Null'),\n  [_types.TypeDefInfo.Option]: (registry, value) => _Option.default.with(getSubType(value)),\n  [_types.TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),\n  [_types.TypeDefInfo.Result]: (registry, value) => {\n    const [Ok, Error] = getTypeClassArray(value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n    return _Result.default.with({\n      Error,\n      Ok\n    });\n  },\n  [_types.TypeDefInfo.Set]: (registry, value) => {\n    const result = {};\n    return _Set.default.with(getSubDefArray(value).reduce((result, {\n      index,\n      name\n    }) => {\n      result[name] = index;\n      return result;\n    }, result), value.length);\n  },\n  [_types.TypeDefInfo.Struct]: (registry, value) => _Struct.default.with(getTypeClassMap(value), value.alias),\n  [_types.TypeDefInfo.Tuple]: (registry, value) => _Tuple.default.with(getTypeClassArray(value)),\n  [_types.TypeDefInfo.UInt]: (registry, value) => createInt(value, _UInt.default),\n  [_types.TypeDefInfo.Vec]: (registry, value) => {\n    const subType = getSubType(value);\n    return subType === 'u8' ? createClass(registry, 'Bytes') : _Vec.default.with(subType);\n  },\n  [_types.TypeDefInfo.VecFixed]: (registry, {\n    displayName,\n    length,\n    sub\n  }) => {\n    (0, _util.assert)((0, _util.isNumber)(length) && !(0, _util.isUndefined)(sub), 'Expected length & type information for fixed vector');\n    return sub.type === 'u8' ? _U8aFixed.default.with(length * 8, displayName) : _VecFixed.default.with(sub.type, length);\n  }\n}; // Returns the type Class for construction\n\nfunction getTypeClass(registry, value) {\n  const Type = registry.get(value.type);\n\n  if (Type) {\n    return Type;\n  }\n\n  const getFn = infoMapping[value.info];\n\n  if (!getFn) {\n    throw new Error(`Unable to construct class from ${JSON.stringify(value)}`);\n  }\n\n  return getFn(registry, value);\n}","map":null,"metadata":{},"sourceType":"script"}