{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Struct = _interopRequireDefault(require(\"../../codec/Struct\"));\n\nvar _constants = require(\"../constants\");\n\nvar _ExtrinsicPayload = _interopRequireDefault(require(\"./ExtrinsicPayload\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name GenericExtrinsicSignatureV2\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\n\n\nclass ExtrinsicSignatureV2 extends _Struct.default {\n  constructor(registry, value, {\n    isSigned\n  } = {}) {\n    super(registry, {\n      signer: 'Address',\n      // eslint-disable-next-line sort-keys\n      signature: 'Signature',\n      // eslint-disable-next-line sort-keys\n      era: 'ExtrinsicEra',\n      nonce: 'Compact<Index>',\n      tip: 'Compact<Balance>'\n    }, ExtrinsicSignatureV2.decodeExtrinsicSignature(value, isSigned));\n  }\n  /** @internal */\n\n\n  static decodeExtrinsicSignature(value, isSigned = false) {\n    if (!value) {\n      return _constants.EMPTY_U8A;\n    } else if (value instanceof ExtrinsicSignatureV2) {\n      return value;\n    }\n\n    return isSigned ? value : _constants.EMPTY_U8A;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.isSigned ? super.encodedLength : 0;\n  }\n  /**\n   * @description `true` if the signature is valid\n   */\n\n\n  get isSigned() {\n    return !this.signature.isEmpty;\n  }\n  /**\n   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n   */\n\n\n  get era() {\n    return this.get('era');\n  }\n  /**\n   * @description The [[Index]] for the signature\n   */\n\n\n  get nonce() {\n    return this.get('nonce');\n  }\n  /**\n   * @description The actual [[Signature]] hash\n   */\n\n\n  get signature() {\n    return this.get('signature');\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n\n\n  get signer() {\n    return this.get('signer');\n  }\n  /**\n   * @description The [[Balance]] tip\n   */\n\n\n  get tip() {\n    return this.get('tip');\n  }\n\n  _injectSignature(signer, signature, {\n    era,\n    nonce,\n    tip\n  }) {\n    this.set('era', era);\n    this.set('nonce', nonce);\n    this.set('signer', signer);\n    this.set('signature', signature);\n    this.set('tip', tip);\n    return this;\n  }\n  /**\n   * @description Adds a raw signature\n   */\n\n\n  addSignature(signer, signature, payload) {\n    return this._injectSignature(this.registry.createType('Address', signer), this.registry.createType('Signature', signature), new _ExtrinsicPayload.default(this.registry, payload));\n  }\n  /**\n   * @description Creates a payload from the supplied options\n   */\n\n\n  createPayload(method, {\n    blockHash,\n    era,\n    genesisHash,\n    nonce,\n    tip\n  }) {\n    return new _ExtrinsicPayload.default(this.registry, {\n      blockHash,\n      era: era || _constants.IMMORTAL_ERA,\n      genesisHash,\n      method: method.toHex(),\n      nonce,\n      // unused for v2\n      specVersion: 0,\n      tip: tip || 0,\n      transactionVersion: 0\n    });\n  }\n  /**\n   * @description Generate a payload and applies the signature from a keypair\n   */\n\n\n  sign(method, account, options) {\n    const address = account.publicKey.length > 32 ? (0, _utilCrypto.blake2AsU8a)(account.publicKey, 256) : account.publicKey;\n    const signer = this.registry.createType('Address', address);\n    const payload = this.createPayload(method, options);\n    const signature = this.registry.createType('Signature', payload.sign(account));\n    return this._injectSignature(signer, signature, payload);\n  }\n  /**\n   * @description Generate a payload and applies a fake signature\n   */\n\n\n  signFake(method, address, options) {\n    const signer = this.registry.createType('Address', address);\n    const payload = this.createPayload(method, options);\n    const signature = this.registry.createType('Signature', new Uint8Array(64).fill(0x42));\n    return this._injectSignature(signer, signature, payload);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isSigned ? super.toU8a(isBare) : _constants.EMPTY_U8A;\n  }\n\n}\n\nexports.default = ExtrinsicSignatureV2;","map":null,"metadata":{},"sourceType":"script"}