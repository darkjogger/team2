{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._stakerRewardsEras = _stakerRewardsEras;\nexports._stakerRewards = _stakerRewards;\nexports.stakerRewards = stakerRewards;\nexports.stakerRewardsMulti = stakerRewardsMulti;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _util2 = require(\"../util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst ZERO = new _bn.default(0);\nconst MIN_ONE = new _bn.default(-1);\nconst COMM_DIV = new _bn.default(1000000000);\nconst MAX_ERAS = new _bn.default(1000000000);\n\nfunction parseRewards(api, stashId, [, erasPoints, erasPrefs, erasRewards], exposures) {\n  return exposures.map(({\n    era,\n    isEmpty,\n    isValidator,\n    nominating,\n    validators: eraValidators\n  }) => {\n    const {\n      eraPoints,\n      validators: allValPoints\n    } = erasPoints.find(p => p.era.eq(era)) || {\n      eraPoints: ZERO,\n      validators: {}\n    };\n    const {\n      eraReward\n    } = erasRewards.find(r => r.era.eq(era)) || {\n      eraReward: api.registry.createType('Balance')\n    };\n    const {\n      validators: allValPrefs\n    } = erasPrefs.find(p => p.era.eq(era)) || {\n      validators: {}\n    };\n    const validators = {};\n    const stakerId = stashId.toString();\n    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n      var _allValPrefs$validato;\n\n      const valPoints = allValPoints[validatorId] || ZERO;\n      const valComm = ((_allValPrefs$validato = allValPrefs[validatorId]) === null || _allValPrefs$validato === void 0 ? void 0 : _allValPrefs$validato.commission.unwrap()) || ZERO;\n      const avail = eraReward.mul(valPoints).div(eraPoints);\n      const valCut = valComm.mul(avail).div(COMM_DIV);\n      const expTotal = exposure.total.unwrap();\n      let value;\n\n      if (!expTotal.isZero() && !valPoints.isZero()) {\n        let staked;\n\n        if (validatorId === stakerId) {\n          staked = exposure.own.unwrap();\n        } else {\n          const stakerExp = exposure.others.find(({\n            who\n          }) => who.eq(stakerId));\n          staked = stakerExp ? stakerExp.value.unwrap() : ZERO;\n        }\n\n        value = avail.sub(valCut).mul(staked).div(expTotal).add(validatorId === stakerId ? valCut : ZERO);\n      }\n\n      validators[validatorId] = {\n        total: api.registry.createType('Balance', avail),\n        value: api.registry.createType('Balance', value)\n      };\n    });\n    return {\n      era,\n      eraReward,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators\n    };\n  });\n}\n\nfunction uniqValidators(rewards) {\n  const uniq = [];\n  rewards.forEach(({\n    validators\n  }) => {\n    Object.keys(validators).forEach(validatorId => {\n      if (!uniq.includes(validatorId)) {\n        uniq.push(validatorId);\n      }\n    });\n  });\n  return uniq;\n}\n\nfunction isOldLedger(ledger) {\n  var _ref;\n\n  return !!((_ref = ledger) === null || _ref === void 0 ? void 0 : _ref.lastReward);\n}\n\nfunction filterEra(era, stakingLedger) {\n  return isOldLedger(stakingLedger) ? era.gt(stakingLedger.lastReward.unwrapOr(MIN_ONE)) : !stakingLedger.claimedRewards.some(e => e.eq(era));\n}\n\nfunction filterEras(eras, stakingLedger) {\n  return eras.filter(era => filterEra(era, stakingLedger));\n}\n\nfunction filterRewards(api, eras, migrateEra, rewards, stakingLedger, withActive) {\n  if (withActive) {\n    return (0, _rxjs.of)(rewards);\n  }\n\n  const validators = uniqValidators(rewards);\n  return ((0, _util.isFunction)(api.tx.staking.payoutStakers) ? api.derive.staking.queryMulti(validators) : (0, _rxjs.of)([])).pipe((0, _operators.map)(queryValidators => {\n    const filter = withActive ? eras : filterEras(eras, stakingLedger);\n    return rewards.filter(({\n      isEmpty\n    }) => !isEmpty).filter(reward => {\n      if (!filter.some(filter => reward.era.eq(filter))) {\n        return false;\n      } else if (reward.era.lt(migrateEra)) {\n        // we filter again here, the actual ledger may have changed, e.g. something has been claimed\n        return filterEra(reward.era, stakingLedger);\n      }\n\n      reward.isStakerPayout = true;\n      const rm = [];\n      Object.keys(reward.validators).forEach(validatorId => {\n        const index = validators.indexOf(validatorId);\n\n        if (index !== -1) {\n          const valLedger = queryValidators[index].stakingLedger;\n\n          if (valLedger === null || valLedger === void 0 ? void 0 : valLedger.claimedRewards.some(era => reward.era.eq(era))) {\n            rm.push(validatorId);\n          }\n        }\n      });\n      rm.forEach(validatorId => {\n        delete reward.validators[validatorId];\n      });\n      return true;\n    }).filter(({\n      validators\n    }) => Object.keys(validators).length !== 0).map(reward => _objectSpread(_objectSpread({}, reward), {}, {\n      nominators: reward.nominating.filter(({\n        validatorId\n      }) => !!reward.validators[validatorId])\n    }));\n  }));\n}\n\nfunction _stakerRewardsEras(api) {\n  return (0, _util2.memo)((eras, withActive) => (0, _rxjs.combineLatest)([(0, _util.isFunction)(api.query.staking.migrateEra) ? api.query.staking.migrateEra() : (0, _rxjs.of)({\n    unwrapOr: () => (0, _util.isFunction)(api.tx.staking.payoutStakers) ? ZERO : MAX_ERAS\n  }), api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]));\n}\n\nfunction _stakerRewards(api) {\n  return (0, _util2.memo)((accountId, eras, withActive) => (0, _rxjs.combineLatest)([api.derive.staking.query(accountId), api.derive.staking._stakerExposure(accountId, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe((0, _operators.switchMap)(([{\n    stakingLedger,\n    stashId\n  }, exposures, erasResult]) => {\n    const migrateEra = erasResult[0].unwrapOr(ZERO);\n\n    if (!stashId || !stakingLedger) {\n      return (0, _rxjs.of)([]);\n    }\n\n    return filterRewards(api, eras, migrateEra, parseRewards(api, stashId, erasResult, exposures), stakingLedger, withActive);\n  })));\n}\n\nfunction stakerRewards(api) {\n  return (0, _util2.memo)((accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._stakerRewards(accountId, eras, withActive))));\n}\n\nfunction stakerRewardsMulti(api) {\n  return (0, _util2.memo)((accountIds, withActive = false) => accountIds.length ? api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => (0, _rxjs.combineLatest)(accountIds.map(acc => api.derive.staking._stakerRewards(acc, eras, withActive))))) : (0, _rxjs.of)([]));\n}","map":null,"metadata":{},"sourceType":"script"}