{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeDef = getTypeDef;\n\nvar _types = require(\"./types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _sanitize = _interopRequireDefault(require(\"./sanitize\"));\n\nvar _typeSplit = require(\"./typeSplit\"); // Copyright 2017-2020 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n// decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n\n\nfunction _decodeEnum(value, details) {\n  value.info = _types.TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  value.sub = Array.isArray(details) ? details.map(name => ({\n    info: _types.TypeDefInfo.Plain,\n    name,\n    type: 'Null'\n  })) : Object.entries(details).map(([name, type]) => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(type || 'Null', {\n    name\n  }));\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = _types.TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: _types.TypeDefInfo.Plain,\n    name,\n    type: name\n  }));\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]]);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.sub = keys.filter(name => !['_alias'].includes(name)).map(name => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(parsed[name], {\n    name\n  }));\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _) {\n  const [vecType, strLength, displayName] = type.substr(1, type.length - 2).split(';');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  (0, _util.assert)(length <= 256, `${type}: Only support for [Type; <length>], where length <= 256`);\n  value.displayName = displayName;\n  value.length = length; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  value.sub = getTypeDef(vecType);\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType) {\n  value.sub = subType.length === 0 ? [] : (0, _typeSplit.typeSplit)(subType).map(inner => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(inner));\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeInt(value, type, _, clazz = 'Int') {\n  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  (0, _util.assert)(length <= 8192 && length % 8 === 0, `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, [start, end]) {\n  if (type.substr(0, start.length) !== start) {\n    return false;\n  }\n\n  (0, _util.assert)(type.endsWith(end), `Expected '${start}' closing with '${end}' on ${type}`);\n  return true;\n}\n\nconst nestedExtraction = [['[', ']', _types.TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', _types.TypeDefInfo.Struct, _decodeStruct], ['(', ')', _types.TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', _types.TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', _types.TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', _types.TypeDefInfo.Int, _decodeInt], ['Result<', '>', _types.TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', _types.TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', _types.TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', _types.TypeDefInfo.BTreeSet], ['Compact<', '>', _types.TypeDefInfo.Compact], ['Linkage<', '>', _types.TypeDefInfo.Linkage], ['Option<', '>', _types.TypeDefInfo.Option], ['Vec<', '>', _types.TypeDefInfo.Vec]];\n\nfunction extractSubType(type, [start, end]) {\n  return type.substr(start.length, type.length - start.length - end.length);\n}\n\nfunction getTypeDef(_type, {\n  displayName,\n  name\n} = {}) {\n  // create the type via Type, allowing types to be sanitized\n  const type = (0, _sanitize.default)(_type);\n  const value = {\n    displayName,\n    info: _types.TypeDefInfo.Plain,\n    name,\n    type\n  };\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested));\n  }\n\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped));\n  }\n\n  return value;\n}","map":null,"metadata":{},"sourceType":"script"}