{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toLatest;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // TODO Handle consts as well\n\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\n\nfunction setTypeOverride(sectionTypes, type) {\n  const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n\n  if (override) {\n    type.setOverride(sectionTypes[override]);\n  }\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(({\n    args,\n    documentation,\n    name\n  }) => {\n    args.forEach(({\n      type\n    }) => setTypeOverride(sectionTypes, type));\n    return registry.createType('FunctionMetadataLatest', {\n      args,\n      documentation,\n      name\n    });\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, {\n  items,\n  prefix\n}, sectionTypes) {\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(({\n      documentation,\n      fallback,\n      modifier,\n      name,\n      type\n    }) => {\n      let resultType;\n\n      if (type.isMap) {\n        resultType = type.asMap.value;\n      } else if (type.isDoubleMap) {\n        resultType = type.asDoubleMap.value;\n      } else {\n        resultType = type.asPlain;\n      }\n\n      setTypeOverride(sectionTypes, resultType);\n      return registry.createType('StorageEntryMetadataLatest', {\n        documentation,\n        fallback,\n        modifier,\n        name,\n        type\n      });\n    }),\n    prefix\n  });\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nfunction toLatest(registry, {\n  extrinsic,\n  modules\n}) {\n  return registry.createType('MetadataLatest', {\n    extrinsic,\n    modules: modules.map(mod => {\n      const calls = mod.calls.unwrapOr(null);\n      const storage = mod.storage.unwrapOr(null);\n      const sectionTypes = (0, _typesKnown.getModuleTypes)(registry, (0, _util.stringCamelCase)(mod.name.toString()));\n      return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n        calls: calls ? convertCalls(registry, calls, sectionTypes) : null,\n        storage: storage ? convertStorage(registry, storage, sectionTypes) : null\n      }));\n    })\n  });\n}","map":null,"metadata":{},"sourceType":"script"}