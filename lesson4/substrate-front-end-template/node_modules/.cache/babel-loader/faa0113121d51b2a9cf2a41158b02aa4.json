{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _eventemitter2 = _interopRequireDefault(require(\"eventemitter3\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _coder2 = _interopRequireDefault(require(\"../coder\"));\n\nvar _defaults = _interopRequireDefault(require(\"../defaults\"));\n\nvar _getWSClass = _interopRequireDefault(require(\"./getWSClass\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst ALIASSES = {\n  chain_finalisedHead: 'chain_finalizedHead',\n  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst l = (0, _util.logger)('api-ws');\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import WsProvider from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\n\nclass WsProvider {\n  /**\n   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n   * @param {boolean} autoConnect Whether to connect automatically or not.\n   */\n  constructor(endpoint = _defaults.default.WS_URL, autoConnectMs = 1000) {\n    Object.defineProperty(this, _coder, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _endpoints, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _eventemitter, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _handlers, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _queued, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _waitingForId, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _autoConnectMs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _endpointIndex, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isConnected, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _subscriptions, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _websocket, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _emit, {\n      writable: true,\n      value: (type, ...args) => {\n        (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].emit(type, ...args);\n      }\n    });\n    Object.defineProperty(this, _onSocketClose, {\n      writable: true,\n      value: event => {\n        if ((0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs] > 0) {\n          l.error(`disconnected from ${(0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex]]} code: '${event.code}' reason: '${event.reason}'`);\n        }\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _isConnected)[_isConnected] = false;\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _emit)[_emit]('disconnected');\n\n        if ((0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs] > 0) {\n          setTimeout(() => {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.connect();\n          }, (0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs]);\n        }\n      }\n    });\n    Object.defineProperty(this, _onSocketError, {\n      writable: true,\n      value: error => {\n        l.debug(() => ['socket error', error]);\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _emit)[_emit]('error', error);\n      }\n    });\n    Object.defineProperty(this, _onSocketMessage, {\n      writable: true,\n      value: message => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        l.debug(() => ['received', message.data]);\n        const response = JSON.parse(message.data);\n        return (0, _util.isUndefined)(response.method) ? (0, _classPrivateFieldLooseBase2.default)(this, _onSocketMessageResult)[_onSocketMessageResult](response) : (0, _classPrivateFieldLooseBase2.default)(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](response);\n      }\n    });\n    Object.defineProperty(this, _onSocketMessageResult, {\n      writable: true,\n      value: response => {\n        const handler = (0, _classPrivateFieldLooseBase2.default)(this, _handlers)[_handlers][response.id];\n\n        if (!handler) {\n          l.debug(() => `Unable to find handler for id=${response.id}`);\n          return;\n        }\n\n        try {\n          const {\n            method,\n            params,\n            subscription\n          } = handler;\n\n          const result = (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].decodeResponse(response); // first send the result - in case of subs, we may have an update\n          // immediately if we have some queued results already\n\n\n          handler.callback(null, result);\n\n          if (subscription) {\n            const subId = `${subscription.type}::${result}`;\n            (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions][subId] = _objectSpread(_objectSpread({}, subscription), {}, {\n              method,\n              params\n            }); // if we have a result waiting for this subscription already\n\n            if ((0, _classPrivateFieldLooseBase2.default)(this, _waitingForId)[_waitingForId][subId]) {\n              (0, _classPrivateFieldLooseBase2.default)(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe]((0, _classPrivateFieldLooseBase2.default)(this, _waitingForId)[_waitingForId][subId]);\n            }\n          }\n        } catch (error) {\n          handler.callback(error, undefined);\n        }\n\n        delete (0, _classPrivateFieldLooseBase2.default)(this, _handlers)[_handlers][response.id];\n      }\n    });\n    Object.defineProperty(this, _onSocketMessageSubscribe, {\n      writable: true,\n      value: response => {\n        const method = ALIASSES[response.method] || response.method || 'invalid';\n        const subId = `${method}::${response.params.subscription}`;\n\n        const handler = (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions][subId];\n\n        if (!handler) {\n          // store the JSON, we could have out-of-order subid coming in\n          (0, _classPrivateFieldLooseBase2.default)(this, _waitingForId)[_waitingForId][subId] = response;\n          l.debug(() => `Unable to find handler for subscription=${subId}`);\n          return;\n        } // housekeeping\n\n\n        delete (0, _classPrivateFieldLooseBase2.default)(this, _waitingForId)[_waitingForId][subId];\n\n        try {\n          const result = (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].decodeResponse(response);\n\n          handler.callback(null, result);\n        } catch (error) {\n          handler.callback(error, undefined);\n        }\n      }\n    });\n    Object.defineProperty(this, _onSocketOpen, {\n      writable: true,\n      value: () => {\n        (0, _util.assert)(!(0, _util.isNull)((0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket]), 'WebSocket cannot be null in onOpen');\n        l.debug(() => ['connected to', (0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex]]]);\n        (0, _classPrivateFieldLooseBase2.default)(this, _isConnected)[_isConnected] = true;\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _emit)[_emit]('connected');\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _sendQueue)[_sendQueue]();\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _resubscribe)[_resubscribe]();\n\n        return true;\n      }\n    });\n    Object.defineProperty(this, _resubscribe, {\n      writable: true,\n      value: () => {\n        const subscriptions = (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions];\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions] = {}; // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n        Object.keys(subscriptions).forEach(async id => {\n          const {\n            callback,\n            method,\n            params,\n            type\n          } = subscriptions[id]; // only re-create subscriptions which are not in author (only area where\n          // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n          // are not included (and will not be re-broadcast)\n\n          if (type.startsWith('author_')) {\n            return;\n          }\n\n          try {\n            await this.subscribe(type, method, params, callback);\n          } catch (error) {\n            l.error(error);\n          }\n        });\n      }\n    });\n    Object.defineProperty(this, _sendQueue, {\n      writable: true,\n      value: () => {\n        Object.keys((0, _classPrivateFieldLooseBase2.default)(this, _queued)[_queued]).forEach(id => {\n          try {\n            // we have done the websocket check in onSocketOpen, if an issue, will catch it\n            (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].send((0, _classPrivateFieldLooseBase2.default)(this, _queued)[_queued][id]);\n\n            delete (0, _classPrivateFieldLooseBase2.default)(this, _queued)[_queued][id];\n          } catch (error) {\n            l.error(error);\n          }\n        });\n      }\n    });\n    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];\n    (0, _util.assert)(endpoints.length !== 0, 'WsProvider requires at least one Endpoint');\n    endpoints.forEach(endpoint => {\n      (0, _util.assert)(/^(wss|ws):\\/\\//.test(endpoint), `Endpoint should start with 'ws://', received '${endpoint}'`);\n    });\n    (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter] = new _eventemitter2.default();\n    (0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs] = autoConnectMs || 0;\n    (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder] = new _coder2.default();\n    (0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex] = -1;\n    (0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints] = endpoints;\n    (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket] = null;\n\n    if (autoConnectMs > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.connect();\n    }\n  }\n  /**\n   * @summary `true` when this provider supports subscriptions\n   */\n\n\n  get hasSubscriptions() {\n    return true;\n  }\n  /**\n   * @description Returns a clone of the object\n   */\n\n\n  clone() {\n    return new WsProvider((0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints]);\n  }\n  /**\n   * @summary Manually connect\n   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n   * connect manually using this method.\n   */\n\n\n  async connect() {\n    try {\n      (0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex] = ((0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex] + 1) % (0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints].length;\n      const WS = await (0, _getWSClass.default)();\n      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket] = new WS((0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex]]);\n      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].onclose = (0, _classPrivateFieldLooseBase2.default)(this, _onSocketClose)[_onSocketClose];\n      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].onerror = (0, _classPrivateFieldLooseBase2.default)(this, _onSocketError)[_onSocketError];\n      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].onmessage = (0, _classPrivateFieldLooseBase2.default)(this, _onSocketMessage)[_onSocketMessage];\n      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].onopen = (0, _classPrivateFieldLooseBase2.default)(this, _onSocketOpen)[_onSocketOpen];\n    } catch (error) {\n      l.error(error);\n    }\n  }\n  /**\n   * @description Manually disconnect from the connection, clearing autoconnect logic\n   */\n\n\n  disconnect() {\n    if ((0, _util.isNull)((0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket])) {\n      throw new Error('Cannot disconnect on a non-open websocket');\n    } // switch off autoConnect, we are in manual mode now\n\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs] = 0; // 1000 - Normal closure; the connection successfully completed\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].close(1000);\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket] = null;\n  }\n  /**\n   * @summary Whether the node is connected or not.\n   * @return {boolean} true if connected\n   */\n\n\n  isConnected() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _isConnected)[_isConnected];\n  }\n  /**\n   * @summary Listens on events after having subscribed using the [[subscribe]] function.\n   * @param  {ProviderInterfaceEmitted} type Event\n   * @param  {ProviderInterfaceEmitCb}  sub  Callback\n   * @return unsubscribe function\n   */\n\n\n  on(type, sub) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].on(type, sub);\n\n    return () => {\n      (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].removeListener(type, sub);\n    };\n  }\n  /**\n   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n   * @param method The RPC methods to execute\n   * @param params Encoded paramaters as appliucable for the method\n   * @param subscription Subscription details (internally used)\n   */\n\n\n  send(method, params, subscription) {\n    return new Promise((resolve, reject) => {\n      try {\n        const json = (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].encodeJson(method, params);\n\n        const id = (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].getId();\n\n        const callback = (error, result) => {\n          error ? reject(error) : resolve(result);\n        };\n\n        l.debug(() => ['calling', method, json]);\n        (0, _classPrivateFieldLooseBase2.default)(this, _handlers)[_handlers][id] = {\n          callback,\n          method,\n          params,\n          subscription\n        };\n\n        if (this.isConnected() && !(0, _util.isNull)((0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket])) {\n          (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].send(json);\n        } else {\n          (0, _classPrivateFieldLooseBase2.default)(this, _queued)[_queued][id] = json;\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  /**\n   * @name subscribe\n   * @summary Allows subscribing to a specific event.\n   * @param  {string}                     type     Subscription type\n   * @param  {string}                     method   Subscription method\n   * @param  {any[]}                 params   Parameters\n   * @param  {ProviderInterfaceCallback} callback Callback\n   * @return {Promise<number>}                     Promise resolving to the dd of the subscription you can use with [[unsubscribe]].\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * const provider = new WsProvider('ws://127.0.0.1:9944');\n   * const rpc = new Rpc(provider);\n   *\n   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n   *   console.log(values)\n   * }).then((subscriptionId) => {\n   *   console.log('balance changes subscription id: ', subscriptionId)\n   * })\n   * ```\n   */\n\n\n  async subscribe(type, method, params, callback) {\n    const id = await this.send(method, params, {\n      callback,\n      type\n    });\n    return id;\n  }\n  /**\n   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n   */\n\n\n  async unsubscribe(type, method, id) {\n    const subscription = `${type}::${id}`; // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n    // the assigned id now does not match what the API user originally received. It has\n    // a slight complication in solving - since we cannot rely on the send id, but rather\n    // need to find the actual subscription id to map it\n\n    if ((0, _util.isUndefined)((0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions][subscription])) {\n      l.debug(() => `Unable to find active subscription=${subscription}`);\n      return false;\n    }\n\n    delete (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions][subscription];\n    const result = await this.send(method, [id]);\n    return result;\n  }\n\n}\n\nexports.default = WsProvider;\n\nvar _coder = (0, _classPrivateFieldLooseKey2.default)(\"coder\");\n\nvar _endpoints = (0, _classPrivateFieldLooseKey2.default)(\"endpoints\");\n\nvar _eventemitter = (0, _classPrivateFieldLooseKey2.default)(\"eventemitter\");\n\nvar _handlers = (0, _classPrivateFieldLooseKey2.default)(\"handlers\");\n\nvar _queued = (0, _classPrivateFieldLooseKey2.default)(\"queued\");\n\nvar _waitingForId = (0, _classPrivateFieldLooseKey2.default)(\"waitingForId\");\n\nvar _autoConnectMs = (0, _classPrivateFieldLooseKey2.default)(\"autoConnectMs\");\n\nvar _endpointIndex = (0, _classPrivateFieldLooseKey2.default)(\"endpointIndex\");\n\nvar _isConnected = (0, _classPrivateFieldLooseKey2.default)(\"isConnected\");\n\nvar _subscriptions = (0, _classPrivateFieldLooseKey2.default)(\"subscriptions\");\n\nvar _websocket = (0, _classPrivateFieldLooseKey2.default)(\"websocket\");\n\nvar _emit = (0, _classPrivateFieldLooseKey2.default)(\"emit\");\n\nvar _onSocketClose = (0, _classPrivateFieldLooseKey2.default)(\"onSocketClose\");\n\nvar _onSocketError = (0, _classPrivateFieldLooseKey2.default)(\"onSocketError\");\n\nvar _onSocketMessage = (0, _classPrivateFieldLooseKey2.default)(\"onSocketMessage\");\n\nvar _onSocketMessageResult = (0, _classPrivateFieldLooseKey2.default)(\"onSocketMessageResult\");\n\nvar _onSocketMessageSubscribe = (0, _classPrivateFieldLooseKey2.default)(\"onSocketMessageSubscribe\");\n\nvar _onSocketOpen = (0, _classPrivateFieldLooseKey2.default)(\"onSocketOpen\");\n\nvar _resubscribe = (0, _classPrivateFieldLooseKey2.default)(\"resubscribe\");\n\nvar _sendQueue = (0, _classPrivateFieldLooseKey2.default)(\"sendQueue\");","map":null,"metadata":{},"sourceType":"script"}