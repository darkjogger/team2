{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _defaults = require(\"@polkadot/util/compact/defaults\");\n\nvar _typeToConstructor = _interopRequireDefault(require(\"./utils/typeToConstructor\"));\n\nvar _Base = _interopRequireDefault(require(\"./Base\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name Compact\n * @description\n * A compact length-encoding codec wrapper. It performs the same function as Length, however\n * differs in that it uses a variable number of bytes to do the actual encoding. This is mostly\n * used by other types to add length-prefixed encoding, or in the case of wrapped types, taking\n * a number and making the compact representation thereof\n */\n\n\nclass Compact extends _Base.default {\n  constructor(registry, Type, value = 0) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    super(registry, Compact.decodeCompact(registry, (0, _typeToConstructor.default)(registry, Type), value));\n  }\n\n  static with(Type) {\n    return class extends Compact {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n\n    };\n  }\n  /**\n   * Prepend a Uint8Array with its compact length.\n   *\n   * @param u8a - The Uint8Array to be prefixed\n   */\n\n\n  static stripLengthPrefix(u8a, bitLength = _defaults.DEFAULT_BITLENGTH) {\n    const [, value] = (0, _util.compactStripLength)(u8a, bitLength);\n    return value;\n  }\n  /** @internal */\n\n\n  static decodeCompact(registry, Type, value) {\n    if (value instanceof Compact) {\n      return new Type(registry, value._raw);\n    } else if ((0, _util.isString)(value) || (0, _util.isNumber)(value) || (0, _util.isBn)(value) || (0, _util.isBigInt)(value)) {\n      return new Type(registry, value);\n    }\n\n    const [, _value] = Compact.decodeU8a(value, new Type(registry, 0).bitLength());\n    return new Type(registry, _value);\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n\n\n  bitLength() {\n    return this._raw.bitLength();\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return this._raw.eq(other instanceof Compact ? other._raw : other);\n  }\n  /**\n   * @description Returns the BN representation of the number\n   */\n\n\n  toBn() {\n    return this._raw.toBn();\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n\n\n  toNumber() {\n    return this._raw.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `Compact<${this._raw.toRawType()}>`;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    return Compact.encodeU8a(this._raw.toBn());\n  }\n  /**\n   * @description Returns the embedded [[UInt]] or [[Moment]] value\n   */\n\n\n  unwrap() {\n    return this._raw;\n  }\n\n}\n\nexports.default = Compact;\nCompact.addLengthPrefix = _util.compactAddLength;\nCompact.decodeU8a = _util.compactFromU8a;\nCompact.encodeU8a = _util.compactToU8a;","map":null,"metadata":{},"sourceType":"script"}