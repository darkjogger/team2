{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n/** ******************************************************************************\n *  (c) 2019 ZondaX GmbH\n *  (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ******************************************************************************* */\n\n\nvar CLA = 0x99;\nvar CHUNK_SIZE = 250;\nvar APP_KEY = \"DOT\";\nvar INS = {\n  GET_VERSION: 0x00,\n  GET_ADDR_ED25519: 0x01,\n  SIGN_ED25519: 0x02\n};\nvar PAYLOAD_TYPE = {\n  INIT: 0x00,\n  ADD: 0x01,\n  LAST: 0x02\n};\nvar ERROR_DESCRIPTION = {\n  1: \"U2F: Unknown\",\n  2: \"U2F: Bad request\",\n  3: \"U2F: Configuration unsupported\",\n  4: \"U2F: Device Ineligible\",\n  5: \"U2F: Timeout\",\n  14: \"Timeout\",\n  0x9000: \"No errors\",\n  0x9001: \"Device is busy\",\n  0x6802: \"Error deriving keys\",\n  0x6400: \"Execution Error\",\n  0x6700: \"Wrong Length\",\n  0x6982: \"Empty Buffer\",\n  0x6983: \"Output buffer too small\",\n  0x6984: \"Data is invalid\",\n  0x6985: \"Conditions not satisfied\",\n  0x6986: \"Transaction rejected\",\n  0x6a80: \"Bad key handle\",\n  0x6b00: \"Invalid P1/P2\",\n  0x6d00: \"Instruction not supported\",\n  0x6e00: \"Ledger app does not seem to be open\",\n  0x6f00: \"Unknown error\",\n  0x6f01: \"Sign/verify error\"\n};\n\nfunction errorCodeToString(statusCode) {\n  if (statusCode in ERROR_DESCRIPTION) return ERROR_DESCRIPTION[statusCode];\n  return \"Unknown Status Code: \".concat(statusCode);\n}\n\nvar LedgerApp = /*#__PURE__*/function () {\n  function LedgerApp(transport) {\n    var scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : APP_KEY;\n    (0, _classCallCheck2.default)(this, LedgerApp);\n\n    if (!transport) {\n      throw new Error(\"Transport has not been defined\");\n    }\n\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getVersion\", \"getAddress\", \"sign\"], scrambleKey);\n  }\n\n  (0, _createClass2.default)(LedgerApp, [{\n    key: \"getVersion\",\n    value: function () {\n      var _getVersion = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.transport.send(CLA, INS.GET_VERSION, 0, 0).then(function (response) {\n                  var errorCodeData = response.slice(-2);\n                  var errorCode = errorCodeData[0] * 256 + errorCodeData[1];\n                  var targetId = 0;\n\n                  if (response.length >= 9) {\n                    /* eslint-disable no-bitwise */\n                    targetId = (response[5] << 24) + (response[6] << 16) + (response[7] << 8) + (response[8] << 0);\n                    /* eslint-enable no-bitwise */\n                  }\n\n                  return {\n                    return_code: errorCode,\n                    error_message: errorCodeToString(errorCode),\n                    //\n                    test_mode: response[0] !== 0,\n                    major: response[1],\n                    minor: response[2],\n                    patch: response[3],\n                    device_locked: response[4] === 1,\n                    target_id: targetId.toString(16)\n                  };\n                }, LedgerApp.processErrorResponse));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getVersion() {\n        return _getVersion.apply(this, arguments);\n      }\n\n      return getVersion;\n    }()\n  }, {\n    key: \"getAddress\",\n    value: function () {\n      var _getAddress = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(account, change, addressIndex) {\n        var requireConfirmation,\n            bip44Path,\n            p1,\n            _args2 = arguments;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                requireConfirmation = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : false;\n                bip44Path = LedgerApp.serializeBIP44(account, change, addressIndex);\n                p1 = 0;\n                if (requireConfirmation) p1 = 1;\n                return _context2.abrupt(\"return\", this.transport.send(CLA, INS.GET_ADDR_ED25519, p1, 0, bip44Path).then(function (response) {\n                  var errorCodeData = response.slice(-2);\n                  var errorCode = errorCodeData[0] * 256 + errorCodeData[1];\n                  return {\n                    pubKey: response.slice(0, 32).toString(\"hex\"),\n                    address: response.slice(32, response.length - 2).toString(\"ascii\"),\n                    return_code: errorCode,\n                    error_message: errorCodeToString(errorCode)\n                  };\n                }, LedgerApp.processErrorResponse));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getAddress(_x, _x2, _x3) {\n        return _getAddress.apply(this, arguments);\n      }\n\n      return getAddress;\n    }()\n  }, {\n    key: \"signSendChunk\",\n    value: function () {\n      var _signSendChunk = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(chunkIdx, chunkNum, chunk) {\n        var payloadType;\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                payloadType = PAYLOAD_TYPE.ADD;\n\n                if (chunkIdx === 1) {\n                  payloadType = PAYLOAD_TYPE.INIT;\n                }\n\n                if (chunkIdx === chunkNum) {\n                  payloadType = PAYLOAD_TYPE.LAST;\n                }\n\n                return _context3.abrupt(\"return\", this.transport.send(CLA, INS.SIGN_ED25519, payloadType, 0, chunk, [0x9000, 0x6984, 0x6a80]).then(function (response) {\n                  var errorCodeData = response.slice(-2);\n                  var returnCode = errorCodeData[0] * 256 + errorCodeData[1];\n                  var errorMessage = errorCodeToString(returnCode);\n                  var signature = null;\n\n                  if (returnCode === 0x6a80 || returnCode === 0x6984) {\n                    errorMessage = response.slice(0, response.length - 2).toString(\"ascii\");\n                  } else if (response.length > 2) {\n                    signature = response.slice(0, response.length - 2);\n                  }\n\n                  return {\n                    signature: signature,\n                    return_code: returnCode,\n                    error_message: errorMessage\n                  };\n                }, LedgerApp.processErrorResponse));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function signSendChunk(_x4, _x5, _x6) {\n        return _signSendChunk.apply(this, arguments);\n      }\n\n      return signSendChunk;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(account, change, addressIndex, message) {\n        var _this = this;\n\n        var chunks;\n        return _regenerator.default.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                chunks = LedgerApp.signGetChunks(account, change, addressIndex, message);\n                return _context5.abrupt(\"return\", this.signSendChunk(1, chunks.length, chunks[0]).then( /*#__PURE__*/function () {\n                  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(result) {\n                    var i;\n                    return _regenerator.default.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            i = 1;\n\n                          case 1:\n                            if (!(i < chunks.length)) {\n                              _context4.next = 10;\n                              break;\n                            }\n\n                            _context4.next = 4;\n                            return _this.signSendChunk(1 + i, chunks.length, chunks[i]);\n\n                          case 4:\n                            result = _context4.sent;\n\n                            if (!(result.return_code !== 0x9000)) {\n                              _context4.next = 7;\n                              break;\n                            }\n\n                            return _context4.abrupt(\"break\", 10);\n\n                          case 7:\n                            i += 1;\n                            _context4.next = 1;\n                            break;\n\n                          case 10:\n                            return _context4.abrupt(\"return\", {\n                              return_code: result.return_code,\n                              error_message: result.error_message,\n                              signature: result.signature\n                            });\n\n                          case 11:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function (_x11) {\n                    return _ref.apply(this, arguments);\n                  };\n                }(), LedgerApp.processErrorResponse));\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sign(_x7, _x8, _x9, _x10) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }], [{\n    key: \"serializeBIP44\",\n    value: function serializeBIP44(account, change, addressIndex) {\n      if (!Number.isInteger(account)) throw new Error(\"Input must be an integer\");\n      if (!Number.isInteger(change)) throw new Error(\"Input must be an integer\");\n      if (!Number.isInteger(addressIndex)) throw new Error(\"Input must be an integer\");\n      var buf = Buffer.alloc(20);\n      buf.writeUInt32LE(0x8000002c, 0);\n      buf.writeUInt32LE(0x800001b2, 4); // eslint-disable-next-line no-bitwise\n\n      buf.writeUInt32LE(account, 8); // eslint-disable-next-line no-bitwise\n\n      buf.writeUInt32LE(change, 12); // eslint-disable-next-line no-bitwise\n\n      buf.writeUInt32LE(addressIndex, 16);\n      return buf;\n    }\n  }, {\n    key: \"signGetChunks\",\n    value: function signGetChunks(account, change, addressIndex, message) {\n      var chunks = [];\n      var bip44Path = LedgerApp.serializeBIP44(account, change, addressIndex);\n      chunks.push(bip44Path);\n      var buffer = Buffer.from(message);\n\n      for (var i = 0; i < buffer.length; i += CHUNK_SIZE) {\n        var end = i + CHUNK_SIZE;\n\n        if (i > buffer.length) {\n          end = buffer.length;\n        }\n\n        chunks.push(buffer.slice(i, end));\n      }\n\n      return chunks;\n    }\n  }, {\n    key: \"processErrorResponse\",\n    value: function processErrorResponse(response) {\n      return {\n        return_code: response.statusCode,\n        error_message: errorCodeToString(response.statusCode)\n      };\n    }\n  }]);\n  return LedgerApp;\n}();\n\nexports.default = LedgerApp;","map":null,"metadata":{},"sourceType":"script"}