{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._account = _account;\nexports.account = account;\nexports.accounts = accounts;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _util2 = require(\"../util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // groups the supplied chunks by era, i.e. { [era]: BN(total of values) }\n\n\nfunction groupByEra(list) {\n  return list.reduce((map, {\n    era,\n    value\n  }) => {\n    const key = era.toString();\n    map[key] = !map[key] ? value.unwrap() : map[key].add(value.unwrap());\n    return map;\n  }, {});\n}\n\nfunction calculateUnlocking(api, stakingLedger, sessionInfo) {\n  if ((0, _util.isUndefined)(stakingLedger)) {\n    return undefined;\n  }\n\n  const unlockingChunks = stakingLedger.unlocking.filter(({\n    era\n  }) => era.unwrap().sub(sessionInfo.activeEra).gtn(0));\n\n  if (!unlockingChunks.length) {\n    return undefined;\n  } // group the unlock chunks that have the same era and sum their values\n\n\n  const groupedResult = groupByEra(unlockingChunks);\n  const results = Object.entries(groupedResult).map(([eraString, value]) => ({\n    remainingEras: new _bn.default(eraString).sub(sessionInfo.activeEra),\n    value: api.registry.createType('Balance', value)\n  }));\n  return results.length ? results : undefined;\n}\n\nfunction redeemableSum(api, stakingLedger, sessionInfo) {\n  if ((0, _util.isUndefined)(stakingLedger)) {\n    return api.registry.createType('Balance');\n  }\n\n  return api.registry.createType('Balance', stakingLedger.unlocking.reduce((total, {\n    era,\n    value\n  }) => {\n    return sessionInfo.activeEra.gte(era.unwrap()) ? total.add(value.unwrap()) : total;\n  }, new _bn.default(0)));\n}\n\nfunction parseResult(api, sessionInfo, query) {\n  return _objectSpread(_objectSpread({}, query), {}, {\n    redeemable: redeemableSum(api, query.stakingLedger, sessionInfo),\n    unlocking: calculateUnlocking(api, query.stakingLedger, sessionInfo)\n  });\n}\n\nfunction _account(api) {\n  return (0, _util2.memo)((sessionInfo, accountId) => api.derive.staking.query(accountId).pipe((0, _operators.map)(query => parseResult(api, sessionInfo, query))));\n}\n/**\n * @description From a stash, retrieve the controllerId and fill in all the relevant staking details\n */\n\n\nfunction account(api) {\n  return (0, _util2.memo)(accountId => api.derive.session.info().pipe((0, _operators.switchMap)(sessionInfo => api.derive.staking._account(sessionInfo, accountId))));\n}\n/**\n * @description From a list of stashes, fill in all the relevant staking details\n */\n\n\nfunction accounts(api) {\n  return (0, _util2.memo)(accountIds => api.derive.session.info().pipe((0, _operators.switchMap)(sessionInfo => (0, _rxjs.combineLatest)(accountIds.map(accountId => api.derive.staking._account(sessionInfo, accountId))))));\n}","map":null,"metadata":{},"sourceType":"script"}