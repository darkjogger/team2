{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeRegistry = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _fromMetadata = _interopRequireDefault(require(\"@polkadot/metadata/Decorated/extrinsics/fromMetadata\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Raw = _interopRequireDefault(require(\"../codec/Raw\"));\n\nvar _signedExtensions2 = require(\"../extrinsic/signedExtensions\");\n\nvar _Event = require(\"../generic/Event\");\n\nvar _DoNotConstruct = _interopRequireDefault(require(\"../primitive/DoNotConstruct\"));\n\nvar _createClass = require(\"./createClass\");\n\nvar _createType = require(\"./createType\");\n\nvar _getTypeDef = require(\"./getTypeDef\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // create error mapping from metadata\n\n\nfunction decorateErrors(_, metadata, metadataErrors) {\n  // decorate the errors\n  metadata.asLatest.modules.forEach((section, sectionIndex) => {\n    const sectionName = (0, _util.stringCamelCase)(section.name.toString());\n    section.errors.forEach(({\n      documentation,\n      name\n    }, index) => {\n      const eventIndex = new Uint8Array([sectionIndex, index]);\n      metadataErrors[(0, _util.u8aToHex)(eventIndex)] = {\n        documentation: documentation.map(d => d.toString()),\n        index,\n        name: name.toString(),\n        section: sectionName\n      };\n    });\n  });\n} // create event classes from metadata\n\n\nfunction decorateEvents(registry, metadata, metadataEvents) {\n  // decorate the events\n  metadata.asLatest.modules.filter(({\n    events\n  }) => events.isSome).forEach((section, sectionIndex) => {\n    const sectionName = (0, _util.stringCamelCase)(section.name.toString());\n    section.events.unwrap().forEach((meta, methodIndex) => {\n      const methodName = meta.name.toString();\n      const eventIndex = new Uint8Array([sectionIndex, methodIndex]); // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access\n\n      const typeDef = meta.args.map(arg => (0, _getTypeDef.getTypeDef)(arg.toString()));\n      let Types = [];\n\n      try {\n        Types = typeDef.map(typeDef => (0, _createClass.getTypeClass)(registry, typeDef));\n      } catch (error) {\n        console.error(error);\n      }\n\n      metadataEvents[(0, _util.u8aToHex)(eventIndex)] = class extends _Event.EventData {\n        constructor(registry, value) {\n          super(registry, Types, value, typeDef, meta, sectionName, methodName);\n        }\n\n      };\n    });\n  });\n} // create extrinsic mapping from metadata\n\n\nfunction decorateExtrinsics(registry, metadata, metadataCalls) {\n  const extrinsics = (0, _fromMetadata.default)(registry, metadata); // decorate the extrinsics\n\n  Object.values(extrinsics).forEach(methods => Object.values(methods).forEach(method => {\n    metadataCalls[(0, _util.u8aToHex)(method.callIndex)] = method;\n  }));\n}\n\nclass TypeRegistry {\n  constructor() {\n    Object.defineProperty(this, _classes, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _definitions, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _metadataCalls, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _metadataErrors, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _metadataEvents, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _unknownTypes, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _chainProperties, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _knownTypes, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _signedExtensions, {\n      writable: true,\n      value: _signedExtensions2.defaultExtensions\n    }); // we only want to import these on creation, i.e. we want to avoid types\n    // weird side-effects from circular references. (Since registry is injected\n    // into types, this can  be a real concern now)\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n    const baseTypes = require('../index.types'); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\n    const definitions = require('../interfaces/definitions'); // since these are classes, they are injected first\n\n\n    this.register(_objectSpread({\n      Raw: _Raw.default\n    }, baseTypes)); // since these are definitions, they would only get created when needed\n\n    Object.values(definitions).forEach(({\n      types\n    }) => this.register(types));\n  }\n\n  get chainDecimals() {\n    var _classPrivateFieldLoo;\n\n    return ((_classPrivateFieldLoo = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.tokenDecimals.isSome) ? (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties].tokenDecimals.unwrap().toNumber() : 12;\n  }\n\n  get chainSS58() {\n    var _classPrivateFieldLoo2;\n\n    return ((_classPrivateFieldLoo2 = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties]) === null || _classPrivateFieldLoo2 === void 0 ? void 0 : _classPrivateFieldLoo2.ss58Format.isSome) ? (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties].ss58Format.unwrap().toNumber() : undefined;\n  }\n\n  get chainToken() {\n    var _classPrivateFieldLoo3;\n\n    return ((_classPrivateFieldLoo3 = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties]) === null || _classPrivateFieldLoo3 === void 0 ? void 0 : _classPrivateFieldLoo3.tokenSymbol.isSome) ? (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties].tokenSymbol.unwrap().toString() : _util.formatBalance.getDefaults().unit;\n  }\n\n  get knownTypes() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _knownTypes)[_knownTypes];\n  }\n\n  get signedExtensions() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions];\n  }\n  /**\n   * @describe Creates an instance of the class\n   */\n\n\n  createClass(type) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return (0, _createClass.createClass)(this, type);\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createType(type, ...params) {\n    return (0, _createType.createType)(this, type, ...params);\n  } // find a specific call\n\n\n  findMetaCall(callIndex) {\n    const hexIndex = (0, _util.u8aToHex)(callIndex);\n\n    const fn = (0, _classPrivateFieldLooseBase2.default)(this, _metadataCalls)[_metadataCalls][hexIndex];\n\n    (0, _util.assert)(!(0, _util.isUndefined)(fn), `findMetaCall: Unable to find Call with index ${hexIndex}/[${callIndex.toString()}]`);\n    return fn;\n  } // finds an error\n\n\n  findMetaError(errorIndex) {\n    const hexIndex = (0, _util.u8aToHex)((0, _util.isU8a)(errorIndex) ? errorIndex : new Uint8Array([errorIndex.index.toNumber(), errorIndex.error.toNumber()]));\n\n    const error = (0, _classPrivateFieldLooseBase2.default)(this, _metadataErrors)[_metadataErrors][hexIndex];\n\n    (0, _util.assert)(!(0, _util.isUndefined)(error), `findMetaError: Unable to find Error with index ${hexIndex}/[${errorIndex.toString()}]`);\n    return error;\n  }\n\n  findMetaEvent(eventIndex) {\n    const hexIndex = (0, _util.u8aToHex)(eventIndex);\n\n    const Event = (0, _classPrivateFieldLooseBase2.default)(this, _metadataEvents)[_metadataEvents][hexIndex];\n\n    (0, _util.assert)(!(0, _util.isUndefined)(Event), `findMetaEvent: Unable to find Event with index ${hexIndex}/[${eventIndex.toString()}]`);\n    return Event;\n  }\n\n  get(name, withUnknown) {\n    let Type = (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].get(name); // we have not already created the type, attempt it\n\n\n    if (!Type) {\n      const definition = (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].get(name);\n\n      let BaseType; // we have a definition, so create the class now (lazily)\n\n      if (definition) {\n        BaseType = (0, _createClass.createClass)(this, definition);\n      } else if (withUnknown) {\n        console.warn(`Unable to resolve type ${name}, it will fail on construction`);\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _unknownTypes)[_unknownTypes].set(name, true);\n\n        BaseType = _DoNotConstruct.default.with(name);\n      }\n\n      if (BaseType) {\n        // NOTE If we didn't extend here, we would have strange artifacts. An example is\n        // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128\n        // Additionally, we now pass through the registry, which is a link to ourselves\n        Type = class extends BaseType {};\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(name, Type);\n      }\n    }\n\n    return Type;\n  }\n\n  getChainProperties() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties];\n  }\n\n  getDefinition(name) {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].get(name);\n  }\n\n  getOrThrow(name, msg) {\n    const Type = this.get(name);\n\n    if ((0, _util.isUndefined)(Type)) {\n      throw new Error(msg || `type ${name} not found`);\n    }\n\n    return Type;\n  }\n\n  getOrUnknown(name) {\n    return this.get(name, true);\n  }\n\n  getSignedExtensionExtra() {\n    return (0, _signedExtensions2.expandExtensionTypes)((0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions], 'extra');\n  }\n\n  getSignedExtensionTypes() {\n    return (0, _signedExtensions2.expandExtensionTypes)((0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions], 'types');\n  }\n\n  hasClass(name) {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].has(name);\n  }\n\n  hasDef(name) {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].has(name);\n  }\n\n  hasType(name) {\n    return !(0, _classPrivateFieldLooseBase2.default)(this, _unknownTypes)[_unknownTypes].get(name) && (this.hasClass(name) || this.hasDef(name));\n  } // eslint-disable-next-line no-dupe-class-members\n\n\n  register(arg1, arg2) {\n    // NOTE Constructors appear as functions here\n    if ((0, _util.isFunction)(arg1)) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(arg1.name, arg1);\n    } else if ((0, _util.isString)(arg1)) {\n      (0, _util.assert)((0, _util.isFunction)(arg2), `Expected class definition passed to '${arg1}' registration`);\n\n      (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(arg1, arg2);\n    } else {\n      this._registerObject(arg1);\n    }\n  }\n\n  _registerObject(obj) {\n    Object.entries(obj).forEach(([name, type]) => {\n      if ((0, _util.isFunction)(type)) {\n        // This _looks_ a bit funny, but `typeof Clazz === 'function'\n        (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(name, type);\n      } else {\n        const def = (0, _util.isString)(type) ? type : JSON.stringify(type); // we already have this type, remove the classes registered for it\n\n        if ((0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].has(name)) {\n          (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].delete(name);\n        }\n\n        (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].set(name, def);\n      }\n    });\n  } // sets the chain properties\n\n\n  setChainProperties(properties) {\n    if (properties) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties] = properties;\n    }\n  }\n\n  setKnownTypes(knownTypes) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _knownTypes)[_knownTypes] = knownTypes;\n  } // sets the metadata\n\n\n  setMetadata(metadata, signedExtensions) {\n    decorateExtrinsics(this, metadata, (0, _classPrivateFieldLooseBase2.default)(this, _metadataCalls)[_metadataCalls]);\n    decorateErrors(this, metadata, (0, _classPrivateFieldLooseBase2.default)(this, _metadataErrors)[_metadataErrors]);\n    decorateEvents(this, metadata, (0, _classPrivateFieldLooseBase2.default)(this, _metadataEvents)[_metadataEvents]); // setup the available extensions\n\n    this.setSignedExtensions(signedExtensions || (metadata.asLatest.extrinsic.version.gtn(0) ? metadata.asLatest.extrinsic.signedExtensions.map(key => key.toString()) : _signedExtensions2.defaultExtensions));\n  } // sets the available signed extensions\n\n\n  setSignedExtensions(signedExtensions = _signedExtensions2.defaultExtensions) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions] = signedExtensions;\n    const unknown = (0, _signedExtensions2.findUnknownExtensions)((0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions]);\n\n    if (unknown.length) {\n      console.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);\n    }\n  }\n\n}\n\nexports.TypeRegistry = TypeRegistry;\n\nvar _classes = (0, _classPrivateFieldLooseKey2.default)(\"classes\");\n\nvar _definitions = (0, _classPrivateFieldLooseKey2.default)(\"definitions\");\n\nvar _metadataCalls = (0, _classPrivateFieldLooseKey2.default)(\"metadataCalls\");\n\nvar _metadataErrors = (0, _classPrivateFieldLooseKey2.default)(\"metadataErrors\");\n\nvar _metadataEvents = (0, _classPrivateFieldLooseKey2.default)(\"metadataEvents\");\n\nvar _unknownTypes = (0, _classPrivateFieldLooseKey2.default)(\"unknownTypes\");\n\nvar _chainProperties = (0, _classPrivateFieldLooseKey2.default)(\"chainProperties\");\n\nvar _knownTypes = (0, _classPrivateFieldLooseKey2.default)(\"knownTypes\");\n\nvar _signedExtensions = (0, _classPrivateFieldLooseKey2.default)(\"signedExtensions\");","map":null,"metadata":{},"sourceType":"script"}