{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Null = _interopRequireDefault(require(\"../primitive/Null\"));\n\nvar _utils = require(\"./utils\");\n\nvar _Base = _interopRequireDefault(require(\"./Base\"));\n\nvar _Struct = _interopRequireDefault(require(\"./Struct\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nfunction extractDef(registry, _def) {\n  if (!Array.isArray(_def)) {\n    const def = (0, _utils.mapToTypeMap)(registry, _def);\n    const isBasic = !Object.values(def).some(type => type !== _Null.default);\n    return {\n      def,\n      isBasic\n    };\n  }\n\n  return {\n    def: _def.reduce((def, key) => {\n      def[key] = _Null.default;\n      return def;\n    }, {}),\n    isBasic: true\n  };\n}\n\nfunction createFromValue(registry, def, index = 0, value) {\n  const Clazz = Object.values(def)[index];\n  (0, _util.assert)(!(0, _util.isUndefined)(Clazz), `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);\n  return {\n    index,\n    value: value instanceof Clazz ? value : new Clazz(registry, value)\n  };\n}\n\nfunction decodeFromJSON(registry, def, key, value) {\n  // JSON comes in the form of { \"<type (lowercased)>\": \"<value for type>\" }, here we\n  // additionally force to lower to ensure forward compat\n  const keys = Object.keys(def).map(k => k.toLowerCase());\n  const keyLower = key.toLowerCase();\n  const index = keys.indexOf(keyLower);\n  (0, _util.assert)(index !== -1, `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);\n  return createFromValue(registry, def, index, value);\n}\n\nfunction decodeFromString(registry, def, value) {\n  return (0, _util.isHex)(value) // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  ? decodeFromValue(registry, def, (0, _util.hexToU8a)(value)) : decodeFromJSON(registry, def, value);\n}\n\nfunction decodeFromValue(registry, def, value) {\n  if ((0, _util.isU8a)(value)) {\n    return createFromValue(registry, def, value[0], value.subarray(1));\n  } else if ((0, _util.isNumber)(value)) {\n    return createFromValue(registry, def, value);\n  } else if ((0, _util.isString)(value)) {\n    return decodeFromString(registry, def, value.toString());\n  } else if ((0, _util.isObject)(value)) {\n    const key = Object.keys(value)[0];\n    return decodeFromJSON(registry, def, key, value[key]);\n  } // Worst-case scenario, return the first with default\n\n\n  return createFromValue(registry, def, 0);\n}\n\nfunction decodeEnum(registry, def, value, index) {\n  // NOTE We check the index path first, before looking at values - this allows treating\n  // the optional indexes before anything else, more-specific > less-specific\n  if ((0, _util.isNumber)(index)) {\n    return createFromValue(registry, def, index, value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (value instanceof Enum) {\n    return createFromValue(registry, def, value.index, value.value);\n  } // Or else, we just look at `value`\n\n\n  return decodeFromValue(registry, def, value);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\n// TODO:\n//   - As per Enum, actually use TS enum\n//   - It should rather probably extend Enum instead of copying code\n\n\nclass Enum extends _Base.default {\n  constructor(registry, def, value, index) {\n    const defInfo = extractDef(registry, def);\n    const decoded = decodeEnum(registry, defInfo.def, value, index);\n    super(registry, decoded.value);\n    this._def = void 0;\n    this._index = void 0;\n    this._indexes = void 0;\n    this._isBasic = void 0;\n    this._def = defInfo.def;\n    this._isBasic = defInfo.isBasic;\n    this._indexes = Object.keys(defInfo.def).map((_, index) => index);\n    this._index = this._indexes.indexOf(decoded.index) || 0;\n  }\n\n  static with(Types) {\n    return class extends Enum {\n      constructor(registry, value, index) {\n        super(registry, Types, value, index);\n        Object.keys(this._def).forEach(_key => {\n          const name = (0, _util.stringUpperFirst)((0, _util.stringCamelCase)(_key.replace(' ', '_')));\n          const askey = `as${name}`;\n          const iskey = `is${name}`; // do not clobber existing properties on the object\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n          if ((0, _util.isUndefined)(this[iskey])) {\n            Object.defineProperty(this, iskey, {\n              enumerable: true,\n              get: () => this.type === _key\n            });\n          } // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n\n          if ((0, _util.isUndefined)(this[askey])) {\n            Object.defineProperty(this, askey, {\n              enumerable: true,\n              get: () => {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                (0, _util.assert)(this[iskey], `Cannot convert '${this.type}' via ${askey}`);\n                return this.value;\n              }\n            });\n          }\n        });\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return 1 + this._raw.encodedLength;\n  }\n  /**\n   * @description The index of the metadata value\n   */\n\n\n  get index() {\n    return this._index;\n  }\n  /**\n   * @description true if this is a basic enum (no values)\n   */\n\n\n  get isBasic() {\n    return this._isBasic;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   */\n\n\n  get isNone() {\n    return this.isNull;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)\n   */\n\n\n  get isNull() {\n    return this._raw instanceof _Null.default;\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defEntries() {\n    return Object.keys(this._def);\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defKeys() {\n    return Object.keys(this._def);\n  }\n  /**\n   * @description The name of the type this enum value represents\n   */\n\n\n  get type() {\n    return this.defKeys[this._index];\n  }\n  /**\n   * @description The value of the enum\n   */\n\n\n  get value() {\n    return this._raw;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    // cater for the case where we only pass the enum index\n    if ((0, _util.isNumber)(other)) {\n      return this.toNumber() === other;\n    } else if (this._isBasic && (0, _util.isString)(other)) {\n      return this.type === other;\n    } else if ((0, _util.isU8a)(other)) {\n      return !this.toU8a().some((entry, index) => entry !== other[index]);\n    } else if ((0, _util.isHex)(other)) {\n      return this.toHex() === other;\n    } else if (other instanceof Enum) {\n      return this.index === other.index && this.value.eq(other.value);\n    } else if ((0, _util.isObject)(other)) {\n      return this.value.eq(other[this.type]);\n    } // compare the actual wrapper value\n\n\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return (0, _util.u8aToHex)(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return this._isBasic ? this.type : {\n      [this.type]: this._raw.toHuman(isExtended)\n    };\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this._isBasic ? this.type : {\n      [this.type]: this._raw.toJSON()\n    };\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n\n\n  toNumber() {\n    return this._index;\n  }\n  /**\n   * @description Returns a raw struct representation of the enum types\n   */\n\n\n  _toRawStruct() {\n    return this._isBasic ? this.defKeys : _Struct.default.typesToMap(this.registry, this._def);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return JSON.stringify({\n      _enum: this._toRawStruct()\n    });\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.isNull ? this.type : JSON.stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const index = this._indexes[this._index];\n    return (0, _util.u8aConcat)(new Uint8Array([index]), this._raw.toU8a(isBare));\n  }\n\n}\n\nexports.default = Enum;","map":null,"metadata":{},"sourceType":"script"}