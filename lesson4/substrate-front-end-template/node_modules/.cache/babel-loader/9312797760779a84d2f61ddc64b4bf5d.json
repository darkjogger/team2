{"ast":null,"code":"/**\nxxHash64 implementation in pure Javascript\n\nCopyright (C) 2016, Pierre Curto\nMIT license\n*/\nvar UINT64 = require('cuint').UINT64;\n/*\n * Constants\n */\n\n\nvar PRIME64_1 = UINT64('11400714785074694791');\nvar PRIME64_2 = UINT64('14029467366897019727');\nvar PRIME64_3 = UINT64('1609587929392839161');\nvar PRIME64_4 = UINT64('9650029242287828579');\nvar PRIME64_5 = UINT64('2870177450012600261');\n/**\n* Convert string to proper UTF-8 array\n* @param str Input string\n* @returns {Uint8Array} UTF8 array is returned as uint8 array\n*/\n\nfunction toUTF8Array(str) {\n  var utf8 = [];\n\n  for (var i = 0, n = str.length; i < n; i++) {\n    var charcode = str.charCodeAt(i);\n    if (charcode < 0x80) utf8.push(charcode);else if (charcode < 0x800) {\n      utf8.push(0xc0 | charcode >> 6, 0x80 | charcode & 0x3f);\n    } else if (charcode < 0xd800 || charcode >= 0xe000) {\n      utf8.push(0xe0 | charcode >> 12, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);\n    } // surrogate pair\n    else {\n        i++; // UTF-16 encodes 0x10000-0x10FFFF by\n        // subtracting 0x10000 and splitting the\n        // 20 bits of 0x0-0xFFFFF into two halves\n\n        charcode = 0x10000 + ((charcode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);\n        utf8.push(0xf0 | charcode >> 18, 0x80 | charcode >> 12 & 0x3f, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);\n      }\n  }\n\n  return new Uint8Array(utf8);\n}\n/**\n * XXH64 object used as a constructor or a function\n * @constructor\n * or\n * @param {Object|String} input data\n * @param {Number|UINT64} seed\n * @return ThisExpression\n * or\n * @return {UINT64} xxHash\n */\n\n\nfunction XXH64() {\n  if (arguments.length == 2) return new XXH64(arguments[1]).update(arguments[0]).digest();\n  if (!(this instanceof XXH64)) return new XXH64(arguments[0]);\n  init.call(this, arguments[0]);\n}\n/**\n * Initialize the XXH64 instance with the given seed\n * @method init\n * @param {Number|Object} seed as a number or an unsigned 32 bits integer\n * @return ThisExpression\n */\n\n\nfunction init(seed) {\n  this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed);\n  this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2);\n  this.v2 = this.seed.clone().add(PRIME64_2);\n  this.v3 = this.seed.clone();\n  this.v4 = this.seed.clone().subtract(PRIME64_1);\n  this.total_len = 0;\n  this.memsize = 0;\n  this.memory = null;\n  return this;\n}\n\nXXH64.prototype.init = init;\n/**\n * Add data to be computed for the XXH64 hash\n * @method update\n * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer\n * @return ThisExpression\n */\n\nXXH64.prototype.update = function (input) {\n  var isString = typeof input == 'string';\n  var isArrayBuffer; // Convert all strings to utf-8 first (issue #5)\n\n  if (isString) {\n    input = toUTF8Array(input);\n    isString = false;\n    isArrayBuffer = true;\n  }\n\n  if (typeof ArrayBuffer !== \"undefined\" && input instanceof ArrayBuffer) {\n    isArrayBuffer = true;\n    input = new Uint8Array(input);\n  }\n\n  var p = 0;\n  var len = input.length;\n  var bEnd = p + len;\n  if (len == 0) return this;\n  this.total_len += len;\n\n  if (this.memsize == 0) {\n    if (isString) {\n      this.memory = '';\n    } else if (isArrayBuffer) {\n      this.memory = new Uint8Array(32);\n    } else {\n      this.memory = new Buffer(32);\n    }\n  }\n\n  if (this.memsize + len < 32) // fill in tmp buffer\n    {\n      // XXH64_memcpy(this.memory + this.memsize, input, len)\n      if (isString) {\n        this.memory += input;\n      } else if (isArrayBuffer) {\n        this.memory.set(input.subarray(0, len), this.memsize);\n      } else {\n        input.copy(this.memory, this.memsize, 0, len);\n      }\n\n      this.memsize += len;\n      return this;\n    }\n\n  if (this.memsize > 0) // some data left from previous update\n    {\n      // XXH64_memcpy(this.memory + this.memsize, input, 16-this.memsize);\n      if (isString) {\n        this.memory += input.slice(0, 32 - this.memsize);\n      } else if (isArrayBuffer) {\n        this.memory.set(input.subarray(0, 32 - this.memsize), this.memsize);\n      } else {\n        input.copy(this.memory, this.memsize, 0, 32 - this.memsize);\n      }\n\n      var p64 = 0;\n\n      if (isString) {\n        var other;\n        other = UINT64(this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64), this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2), this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4), this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6));\n        this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p64 += 8;\n        other = UINT64(this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64), this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2), this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4), this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6));\n        this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p64 += 8;\n        other = UINT64(this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64), this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2), this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4), this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6));\n        this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p64 += 8;\n        other = UINT64(this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64), this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2), this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4), this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6));\n        this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n      } else {\n        var other;\n        other = UINT64(this.memory[p64 + 1] << 8 | this.memory[p64], this.memory[p64 + 3] << 8 | this.memory[p64 + 2], this.memory[p64 + 5] << 8 | this.memory[p64 + 4], this.memory[p64 + 7] << 8 | this.memory[p64 + 6]);\n        this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p64 += 8;\n        other = UINT64(this.memory[p64 + 1] << 8 | this.memory[p64], this.memory[p64 + 3] << 8 | this.memory[p64 + 2], this.memory[p64 + 5] << 8 | this.memory[p64 + 4], this.memory[p64 + 7] << 8 | this.memory[p64 + 6]);\n        this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p64 += 8;\n        other = UINT64(this.memory[p64 + 1] << 8 | this.memory[p64], this.memory[p64 + 3] << 8 | this.memory[p64 + 2], this.memory[p64 + 5] << 8 | this.memory[p64 + 4], this.memory[p64 + 7] << 8 | this.memory[p64 + 6]);\n        this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p64 += 8;\n        other = UINT64(this.memory[p64 + 1] << 8 | this.memory[p64], this.memory[p64 + 3] << 8 | this.memory[p64 + 2], this.memory[p64 + 5] << 8 | this.memory[p64 + 4], this.memory[p64 + 7] << 8 | this.memory[p64 + 6]);\n        this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n      }\n\n      p += 32 - this.memsize;\n      this.memsize = 0;\n      if (isString) this.memory = '';\n    }\n\n  if (p <= bEnd - 32) {\n    var limit = bEnd - 32;\n\n    do {\n      if (isString) {\n        var other;\n        other = UINT64(input.charCodeAt(p + 1) << 8 | input.charCodeAt(p), input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2), input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4), input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6));\n        this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p += 8;\n        other = UINT64(input.charCodeAt(p + 1) << 8 | input.charCodeAt(p), input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2), input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4), input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6));\n        this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p += 8;\n        other = UINT64(input.charCodeAt(p + 1) << 8 | input.charCodeAt(p), input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2), input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4), input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6));\n        this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p += 8;\n        other = UINT64(input.charCodeAt(p + 1) << 8 | input.charCodeAt(p), input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2), input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4), input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6));\n        this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n      } else {\n        var other;\n        other = UINT64(input[p + 1] << 8 | input[p], input[p + 3] << 8 | input[p + 2], input[p + 5] << 8 | input[p + 4], input[p + 7] << 8 | input[p + 6]);\n        this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p += 8;\n        other = UINT64(input[p + 1] << 8 | input[p], input[p + 3] << 8 | input[p + 2], input[p + 5] << 8 | input[p + 4], input[p + 7] << 8 | input[p + 6]);\n        this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p += 8;\n        other = UINT64(input[p + 1] << 8 | input[p], input[p + 3] << 8 | input[p + 2], input[p + 5] << 8 | input[p + 4], input[p + 7] << 8 | input[p + 6]);\n        this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n        p += 8;\n        other = UINT64(input[p + 1] << 8 | input[p], input[p + 3] << 8 | input[p + 2], input[p + 5] << 8 | input[p + 4], input[p + 7] << 8 | input[p + 6]);\n        this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);\n      }\n\n      p += 8;\n    } while (p <= limit);\n  }\n\n  if (p < bEnd) {\n    // XXH64_memcpy(this.memory, p, bEnd-p);\n    if (isString) {\n      this.memory += input.slice(p);\n    } else if (isArrayBuffer) {\n      this.memory.set(input.subarray(p, bEnd), this.memsize);\n    } else {\n      input.copy(this.memory, this.memsize, p, bEnd);\n    }\n\n    this.memsize = bEnd - p;\n  }\n\n  return this;\n};\n/**\n * Finalize the XXH64 computation. The XXH64 instance is ready for reuse for the given seed\n * @method digest\n * @return {UINT64} xxHash\n */\n\n\nXXH64.prototype.digest = function () {\n  var input = this.memory;\n  var isString = typeof input == 'string';\n  var p = 0;\n  var bEnd = this.memsize;\n  var h64, h;\n  var u = new UINT64();\n\n  if (this.total_len >= 32) {\n    h64 = this.v1.clone().rotl(1);\n    h64.add(this.v2.clone().rotl(7));\n    h64.add(this.v3.clone().rotl(12));\n    h64.add(this.v4.clone().rotl(18));\n    h64.xor(this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));\n    h64.multiply(PRIME64_1).add(PRIME64_4);\n    h64.xor(this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));\n    h64.multiply(PRIME64_1).add(PRIME64_4);\n    h64.xor(this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));\n    h64.multiply(PRIME64_1).add(PRIME64_4);\n    h64.xor(this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));\n    h64.multiply(PRIME64_1).add(PRIME64_4);\n  } else {\n    h64 = this.seed.clone().add(PRIME64_5);\n  }\n\n  h64.add(u.fromNumber(this.total_len));\n\n  while (p <= bEnd - 8) {\n    if (isString) {\n      u.fromBits(input.charCodeAt(p + 1) << 8 | input.charCodeAt(p), input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2), input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4), input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6));\n    } else {\n      u.fromBits(input[p + 1] << 8 | input[p], input[p + 3] << 8 | input[p + 2], input[p + 5] << 8 | input[p + 4], input[p + 7] << 8 | input[p + 6]);\n    }\n\n    u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1);\n    h64.xor(u).rotl(27).multiply(PRIME64_1).add(PRIME64_4);\n    p += 8;\n  }\n\n  if (p + 4 <= bEnd) {\n    if (isString) {\n      u.fromBits(input.charCodeAt(p + 1) << 8 | input.charCodeAt(p), input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2), 0, 0);\n    } else {\n      u.fromBits(input[p + 1] << 8 | input[p], input[p + 3] << 8 | input[p + 2], 0, 0);\n    }\n\n    h64.xor(u.multiply(PRIME64_1)).rotl(23).multiply(PRIME64_2).add(PRIME64_3);\n    p += 4;\n  }\n\n  while (p < bEnd) {\n    u.fromBits(isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0);\n    h64.xor(u.multiply(PRIME64_5)).rotl(11).multiply(PRIME64_1);\n  }\n\n  h = h64.clone().shiftRight(33);\n  h64.xor(h).multiply(PRIME64_2);\n  h = h64.clone().shiftRight(29);\n  h64.xor(h).multiply(PRIME64_3);\n  h = h64.clone().shiftRight(32);\n  h64.xor(h); // Reset the state\n\n  this.init(this.seed);\n  return h64;\n};\n\nmodule.exports = XXH64;","map":null,"metadata":{},"sourceType":"script"}