{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPair;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _toJson = _interopRequireDefault(require(\"./toJson\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst SIG_TYPE_NONE = new Uint8Array();\nconst SIG_TYPE_ED25519 = new Uint8Array([0]);\nconst SIG_TYPE_SR25519 = new Uint8Array([1]);\nconst SIG_TYPE_ECDSA = new Uint8Array([2]);\n\nfunction isEmpty(u8a) {\n  return u8a.reduce((count, u8) => count + u8, 0) === 0;\n}\n\nfunction fromSeed(type, seed) {\n  return {\n    ecdsa: () => (0, _utilCrypto.secp256k1KeypairFromSeed)(seed),\n    ed25519: () => (0, _utilCrypto.naclKeypairFromSeed)(seed),\n    sr25519: () => (0, _utilCrypto.schnorrkelKeypairFromSeed)(seed)\n  }[type]();\n}\n\nfunction multiSignaturePrefix(type) {\n  return {\n    ecdsa: SIG_TYPE_ECDSA,\n    ed25519: SIG_TYPE_ED25519,\n    sr25519: SIG_TYPE_SR25519\n  }[type];\n}\n\nfunction sign(type, message, pair, {\n  withType = false\n} = {}) {\n  const signature = {\n    ecdsa: () => (0, _utilCrypto.secp256k1Sign)(message, pair),\n    ed25519: () => (0, _utilCrypto.naclSign)(message, pair),\n    sr25519: () => (0, _utilCrypto.schnorrkelSign)(message, pair)\n  }[type]();\n  return (0, _util.u8aConcat)( // for multi-signatures, i.e. with indicator, append the signature type as per\n  // the MultiSignature enum\n  withType ? multiSignaturePrefix(type) : SIG_TYPE_NONE, signature);\n}\n\nfunction verify(type, message, signature, publicKey) {\n  return {\n    ecdsa: () => (0, _utilCrypto.secp256k1Verify)(message, signature, (0, _utilCrypto.blake2AsU8a)(publicKey, 256)),\n    ed25519: () => (0, _utilCrypto.naclVerify)(message, signature, publicKey),\n    sr25519: () => (0, _utilCrypto.schnorrkelVerify)(message, signature, publicKey)\n  }[type]();\n}\n\nfunction getAddress(type, publicKey) {\n  if (type === 'ecdsa' && publicKey.length > 32) {\n    return (0, _utilCrypto.blake2AsU8a)(publicKey, 256);\n  } else {\n    return publicKey;\n  }\n} // Not 100% correct, since it can be a Uint8Array, but an invalid one - just say \"undefined\" is anything non-valid\n\n\nfunction isLocked(secretKey) {\n  return !secretKey || secretKey.length === 0 || isEmpty(secretKey);\n}\n/**\n * @name pair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\n\nfunction createPair({\n  toSS58,\n  type\n}, {\n  publicKey,\n  secretKey\n}, meta = {}, encoded = null) {\n  return {\n    get address() {\n      return toSS58(getAddress(type, publicKey));\n    },\n\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n\n    get meta() {\n      return meta;\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    get type() {\n      return type;\n    },\n\n    // eslint-disable-next-line sort-keys\n    decodePkcs8: (passphrase, _encoded) => {\n      const decoded = (0, _decode.default)(passphrase, _encoded || encoded);\n\n      if (decoded.secretKey.length === 64) {\n        publicKey = decoded.publicKey;\n        secretKey = decoded.secretKey;\n      } else {\n        const pair = fromSeed(type, decoded.secretKey);\n        publicKey = pair.publicKey;\n        secretKey = pair.secretKey;\n      }\n    },\n    derive: (suri, meta) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot derive on a locked keypair');\n      const {\n        path\n      } = (0, _utilCrypto.keyExtractPath)(suri);\n      const derived = (0, _utilCrypto.keyFromPath)({\n        publicKey,\n        secretKey\n      }, path, type);\n      return createPair({\n        toSS58,\n        type\n      }, derived, meta, null);\n    },\n    encodePkcs8: passphrase => (0, _encode.default)({\n      publicKey,\n      secretKey\n    }, passphrase),\n    lock: () => {\n      secretKey = new Uint8Array(0);\n    },\n    setMeta: additional => {\n      meta = _objectSpread(_objectSpread({}, meta), additional);\n    },\n    sign: (message, options) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n      return sign(type, message, {\n        publicKey,\n        secretKey\n      }, options);\n    },\n    toJson: passphrase => (0, _toJson.default)(type, {\n      address: toSS58(getAddress(type, publicKey)),\n      meta\n    }, (0, _encode.default)({\n      publicKey,\n      secretKey\n    }, passphrase), !!passphrase),\n    verify: (message, signature) => verify(type, message, signature, publicKey)\n  };\n}","map":null,"metadata":{},"sourceType":"script"}