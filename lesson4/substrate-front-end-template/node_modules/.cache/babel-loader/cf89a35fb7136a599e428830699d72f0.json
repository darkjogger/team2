{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.LEDGER_DEFAULT_INDEX = exports.LEDGER_DEFAULT_CHANGE = exports.LEDGER_DEFAULT_ACCOUNT = void 0;\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _ledgerPolkadot = _interopRequireDefault(require(\"ledger-polkadot\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _transportsNode = _interopRequireDefault(require(\"./transportsNode\"));\n\nvar _transportsWeb = _interopRequireDefault(require(\"./transportsWeb\")); // Copyright 2017-2020 @polkadot/ui-keyring authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst LEDGER_DEFAULT_ACCOUNT = 0x80000000;\nexports.LEDGER_DEFAULT_ACCOUNT = LEDGER_DEFAULT_ACCOUNT;\nconst LEDGER_DEFAULT_CHANGE = 0x80000000;\nexports.LEDGER_DEFAULT_CHANGE = LEDGER_DEFAULT_CHANGE;\nconst LEDGER_DEFAULT_INDEX = 0x80000000;\nexports.LEDGER_DEFAULT_INDEX = LEDGER_DEFAULT_INDEX;\nconst SUCCESS_CODE = 0x9000;\n\nconst transports = _transportsNode.default.concat(_transportsWeb.default); // A very basic wrapper for a ledger app -\n//  - it connects automatically, creating an app as required\n//  - Promises return errors (instead of wrapper errors)\n\n\nclass Ledger {\n  constructor(type) {\n    Object.defineProperty(this, _app, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    }); // u2f is deprecated\n\n    (0, _util.assert)(['hid', 'webusb'].includes(type), `Unsupported transport ${type}`);\n    (0, _classPrivateFieldLooseBase2.default)(this, _type)[_type] = type;\n  }\n\n  async _getApp() {\n    if (!(0, _classPrivateFieldLooseBase2.default)(this, _app)[_app]) {\n      const def = transports.find(({\n        type\n      }) => type === (0, _classPrivateFieldLooseBase2.default)(this, _type)[_type]);\n      (0, _util.assert)(def, `Unable to find a transport for ${(0, _classPrivateFieldLooseBase2.default)(this, _type)[_type]}`);\n      const transport = await def.create();\n      (0, _classPrivateFieldLooseBase2.default)(this, _app)[_app] = new _ledgerPolkadot.default(transport);\n    }\n\n    return (0, _classPrivateFieldLooseBase2.default)(this, _app)[_app];\n  }\n\n  async _withApp(fn) {\n    try {\n      const app = await this._getApp();\n      return await fn(app);\n    } catch (error) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _app)[_app] = null;\n      throw error;\n    }\n  }\n\n  async _wrapError(promise) {\n    const result = await promise;\n    (0, _util.assert)(result.return_code === SUCCESS_CODE, result.error_message);\n    return result;\n  }\n\n  async getAddress(confirm = false, account = LEDGER_DEFAULT_ACCOUNT, change = LEDGER_DEFAULT_CHANGE, addressIndex = LEDGER_DEFAULT_INDEX) {\n    return this._withApp(async app => {\n      const {\n        address,\n        pubKey\n      } = await this._wrapError(app.getAddress(account, change, addressIndex, confirm));\n      return {\n        address,\n        publicKey: `0x${pubKey}`\n      };\n    });\n  }\n\n  async getVersion() {\n    return this._withApp(async app => {\n      const {\n        device_locked: isLocked,\n        major,\n        minor,\n        patch,\n        test_mode: isTestMode\n      } = await this._wrapError(app.getVersion());\n      return {\n        isLocked,\n        isTestMode,\n        version: [major, minor, patch]\n      };\n    });\n  }\n\n  async sign(message, account = LEDGER_DEFAULT_ACCOUNT, change = LEDGER_DEFAULT_CHANGE, addressIndex = LEDGER_DEFAULT_INDEX) {\n    return this._withApp(async app => {\n      const buffer = (0, _util.u8aToBuffer)(message);\n      const {\n        signature\n      } = await this._wrapError(app.sign(account, change, addressIndex, buffer));\n      return {\n        signature: (0, _util.u8aToHex)((0, _util.bufferToU8a)(signature))\n      };\n    });\n  }\n\n}\n\nexports.default = Ledger;\n\nvar _app = (0, _classPrivateFieldLooseKey2.default)(\"app\");\n\nvar _type = (0, _classPrivateFieldLooseKey2.default)(\"type\");","map":null,"metadata":{},"sourceType":"script"}