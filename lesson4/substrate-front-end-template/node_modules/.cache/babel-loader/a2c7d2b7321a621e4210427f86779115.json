{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.DEFAULT_UINT_BITS = void 0;\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Raw = _interopRequireDefault(require(\"./Raw\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst DEFAULT_UINT_BITS = 64;\nexports.DEFAULT_UINT_BITS = DEFAULT_UINT_BITS;\nconst PER_B = new _bn.default(1000000000);\nconst PER_M = new _bn.default(1000000);\nconst MUL_P = new _bn.default(10000);\n\nfunction toPercentage(value, divisor) {\n  return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;\n}\n/** @internal */\n\n\nfunction decodeAbstracIntU8a(value, bitLength, isNegative) {\n  if (!value.length) {\n    return '0';\n  }\n\n  try {\n    // NOTE When passing u8a in (typically from decoded data), it is always Little Endian\n    return (0, _util.u8aToBn)(value.subarray(0, bitLength / 8), {\n      isLe: true,\n      isNegative\n    }).toString();\n  } catch (error) {\n    throw new Error(`AbstractInt: failed on ${JSON.stringify(value)}:: ${error.message}`);\n  }\n}\n/** @internal */\n\n\nfunction decodeAbstracInt(value, bitLength, isNegative) {\n  // This function returns a string, which will be passed in the BN\n  // constructor. It would be ideal to actually return a BN, but there's a\n  // bug: https://github.com/indutny/bn.js/issues/206.\n  if ((0, _util.isHex)(value, -1, true)) {\n    return (0, _util.hexToBn)(value, {\n      isLe: false,\n      isNegative\n    }).toString();\n  } else if ((0, _util.isU8a)(value)) {\n    return decodeAbstracIntU8a(value, bitLength, isNegative);\n  } else if ((0, _util.isString)(value)) {\n    return new _bn.default(value.toString(), 10).toString();\n  }\n\n  return (0, _util.bnToBn)(value).toString();\n}\n/**\n * @name AbstractInt\n * @ignore\n * @noInheritDoc\n */\n// TODO:\n//   - Apart from encoding/decoding we don't actually keep check on the sizes, is this good enough?\n\n\nclass AbstractInt extends _bn.default {\n  constructor(registry, isSigned, value = 0, bitLength = DEFAULT_UINT_BITS, isHexJson = true) {\n    super(decodeAbstracInt(value, bitLength, isSigned));\n    this.registry = void 0;\n    Object.defineProperty(this, _bitLength, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isHexJson, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isSigned, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    (0, _classPrivateFieldLooseBase2.default)(this, _bitLength)[_bitLength] = bitLength;\n    (0, _classPrivateFieldLooseBase2.default)(this, _isHexJson)[_isHexJson] = isHexJson;\n    (0, _classPrivateFieldLooseBase2.default)(this, _isSigned)[_isSigned] = isSigned;\n    (0, _util.assert)(super.bitLength() <= bitLength, `${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${bitLength}`);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _bitLength)[_bitLength] / 8;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return new _Raw.default(this.registry, (0, _utilCrypto.blake2AsU8a)(this.toU8a(), 256));\n  }\n  /**\n   * @description Checks if the value is a zero value (align elsewhere)\n   */\n\n\n  get isEmpty() {\n    return this.isZero();\n  }\n  /**\n   * @description Checks if the value is an unsigned type\n   */\n\n\n  get isUnsigned() {\n    return !(0, _classPrivateFieldLooseBase2.default)(this, _isSigned)[_isSigned];\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n\n\n  bitLength() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _bitLength)[_bitLength];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  eq(other) {\n    // Here we are actually overriding the built-in .eq to take care of both\n    // number and BN inputs (no `.eqn` needed) - numbers will be converted\n    return super.eq((0, _util.isHex)(other) ? (0, _util.hexToBn)(other.toString(), {\n      isLe: false,\n      isNegative: (0, _classPrivateFieldLooseBase2.default)(this, _isSigned)[_isSigned]\n    }) : (0, _util.bnToBn)(other));\n  }\n  /**\n   * @description True if this value is the max of the type\n   */\n\n\n  isMax() {\n    const u8a = this.toU8a().filter(byte => byte === 0xff);\n    return u8a.length === (0, _classPrivateFieldLooseBase2.default)(this, _bitLength)[_bitLength] / 8;\n  }\n  /**\n   * @description Returns the BN representation of the number. (Compatibility)\n   */\n\n\n  toBn() {\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex(isLe = false) {\n    // For display/JSON, this is BE, for compare, use isLe\n    return (0, _util.bnToHex)(this, {\n      bitLength: this.bitLength(),\n      isLe,\n      isNegative: !this.isUnsigned\n    });\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toHuman(isExpanded) {\n    // FIXME we need proper expansion here\n    return this instanceof this.registry.createClass('Balance') ? this.isMax() ? 'everything' : (0, _util.formatBalance)(this, {\n      decimals: this.registry.chainDecimals,\n      withSi: true,\n      withUnit: this.registry.chainToken\n    }) : this instanceof this.registry.createClass('Perbill') ? toPercentage(this, PER_B) : this instanceof this.registry.createClass('Permill') ? toPercentage(this, PER_M) : (0, _util.formatNumber)(this);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    // FIXME this return type should by string | number, but BN's return type\n    // is string.\n    // Maximum allowed integer for JS is 2^53 - 1, set limit at 52\n    return (0, _classPrivateFieldLooseBase2.default)(this, _isHexJson)[_isHexJson] || super.bitLength() > 52 ? this.toHex() : this.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    // NOTE In the case of balances, which have a special meaning on the UI\n    // and can be interpreted differently, return a specific value for it so\n    // underlying it always matches (no matter which length it actually is)\n    return this instanceof this.registry.createClass('Balance') ? 'Balance' : `${this.isUnsigned ? 'u' : 'i'}${this.bitLength()}`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   * @param base The base to use for the conversion\n   */\n\n\n  toString(base) {\n    // only included here since we do not inherit docs\n    return super.toString(base);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    return (0, _util.bnToU8a)(this, {\n      bitLength: this.bitLength(),\n      isLe: true,\n      isNegative: !this.isUnsigned\n    });\n  }\n\n}\n\nexports.default = AbstractInt;\n\nvar _bitLength = (0, _classPrivateFieldLooseKey2.default)(\"bitLength\");\n\nvar _isHexJson = (0, _classPrivateFieldLooseKey2.default)(\"isHexJson\");\n\nvar _isSigned = (0, _classPrivateFieldLooseKey2.default)(\"isSigned\");","map":null,"metadata":{},"sourceType":"script"}