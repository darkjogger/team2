{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unwrapStorageType = unwrapStorageType;\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Bytes = _interopRequireDefault(require(\"./Bytes\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst HASHER_MAP = {\n  // opaque\n  Blake2_128: [16, false],\n  // eslint-disable-line camelcase\n  Blake2_128Concat: [16, true],\n  // eslint-disable-line camelcase\n  Blake2_256: [32, false],\n  // eslint-disable-line camelcase\n  Identity: [0, true],\n  Twox128: [16, false],\n  Twox256: [32, false],\n  Twox64Concat: [8, true]\n};\n\nfunction getStorageType(type, isOptionalLinked) {\n  if (type.isPlain) {\n    return [false, type.asPlain.toString()];\n  } else if (type.isDoubleMap) {\n    return [false, type.asDoubleMap.value.toString()];\n  }\n\n  const map = type.asMap;\n\n  if (map.linked.isTrue) {\n    const [pre, post] = isOptionalLinked ? ['Option<', '>'] : ['', ''];\n    return [true, `(${pre}${map.value.toString()}${post}, Linkage<${map.key.toString()}>)`];\n  }\n\n  return [false, map.value.toString()];\n} // we unwrap the type here, turning into an output usable for createType\n\n/** @internal */\n\n\nfunction unwrapStorageType(type, isOptional) {\n  const [hasWrapper, outputType] = getStorageType(type, isOptional);\n  return isOptional && !hasWrapper ? `Option<${outputType}>` : outputType;\n}\n/** @internal */\n\n\nfunction decodeStorageKey(value) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  if (value instanceof StorageKey) {\n    return {\n      key: value,\n      method: value.method,\n      section: value.section\n    };\n  } else if (!value || (0, _util.isString)(value) || (0, _util.isU8a)(value)) {\n    // let Bytes handle these inputs\n    return {\n      key: value\n    };\n  } else if ((0, _util.isFunction)(value)) {\n    return {\n      key: value(),\n      method: value.method,\n      section: value.section\n    };\n  } else if (Array.isArray(value)) {\n    const [fn, ...arg] = value;\n    (0, _util.assert)((0, _util.isFunction)(fn), 'Expected function input for key construction');\n    return {\n      key: fn(...arg),\n      method: fn.method,\n      section: fn.section\n    };\n  }\n\n  throw new Error(`Unable to convert input ${value} to StorageKey`);\n}\n\nfunction decodeHashers(registry, value, hashers) {\n  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total\n  let offset = 32;\n  return hashers.reduce((result, [hasher, type]) => {\n    const [hashLen, canDecode] = HASHER_MAP[hasher.type];\n    const decoded = canDecode ? registry.createType(type, value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));\n    offset += hashLen + (canDecode ? decoded.encodedLength : 0);\n    result.push(decoded);\n    return result;\n  }, []);\n}\n/** @internal */\n\n\nfunction decodeArgsFromMeta(registry, value, meta) {\n  if (!meta || !(meta.type.isDoubleMap || meta.type.isMap)) {\n    return [];\n  }\n\n  if (meta.type.isMap) {\n    const mapInfo = meta.type.asMap;\n    return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key.toString()]]);\n  }\n\n  const mapInfo = meta.type.asDoubleMap;\n  return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key1.toString()], [mapInfo.key2Hasher, mapInfo.key2.toString()]]);\n}\n/**\n * @name StorageKey\n * @description\n * A representation of a storage key (typically hashed) in the system. It can be\n * constructed by passing in a raw key or a StorageEntry with (optional) arguments.\n */\n\n\nclass StorageKey extends _Bytes.default {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore This is assigned via this.decodeArgsFromMeta()\n  constructor(registry, value, override = {}) {\n    const {\n      key,\n      method,\n      section\n    } = decodeStorageKey(value);\n    super(registry, key);\n    this._args = void 0;\n    this._meta = void 0;\n    this._outputType = void 0;\n    this._method = void 0;\n    this._section = void 0;\n    this._method = override.method || method;\n    this._section = override.section || section;\n    this._outputType = StorageKey.getType(value); // decode the args (as applicable based on the key and the hashers, after all init)\n\n    this.setMeta(StorageKey.getMeta(value));\n  }\n\n  static getMeta(value) {\n    if (value instanceof StorageKey) {\n      return value.meta;\n    } else if ((0, _util.isFunction)(value)) {\n      return value.meta;\n    } else if (Array.isArray(value)) {\n      const [fn] = value;\n      return fn.meta;\n    }\n\n    return undefined;\n  }\n\n  static getType(value) {\n    if (value instanceof StorageKey) {\n      return value.outputType;\n    } else if ((0, _util.isFunction)(value)) {\n      return unwrapStorageType(value.meta.type);\n    } else if (Array.isArray(value)) {\n      const [fn] = value;\n\n      if (fn.meta) {\n        return unwrapStorageType(fn.meta.type);\n      }\n    } // If we have no type set, default to Raw\n\n\n    return 'Raw';\n  }\n  /**\n   * @description Return the decoded arguments (applicable to map/doublemap with decodable values)\n   */\n\n\n  get args() {\n    return this._args;\n  }\n  /**\n   * @description The metadata or `undefined` when not available\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description The key method or `undefined` when not specified\n   */\n\n\n  get method() {\n    return this._method;\n  }\n  /**\n   * @description The output type\n   */\n\n\n  get outputType() {\n    return this._outputType;\n  }\n  /**\n   * @description The key section or `undefined` when not specified\n   */\n\n\n  get section() {\n    return this._section;\n  }\n  /**\n   * @description Sets the meta for this key\n   */\n\n\n  setMeta(meta) {\n    this._meta = meta;\n\n    if (meta) {\n      this._outputType = unwrapStorageType(meta.type);\n    }\n\n    try {\n      this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);\n    } catch (error) {// ignore...\n    }\n\n    return this;\n  }\n  /**\n   * @description Returns the Human representation for this type\n   */\n\n\n  toHuman() {\n    return this._args.length ? this._args.map(arg => arg.toHuman()) : super.toHuman();\n  }\n  /**\n   * @description Returns the raw type for this\n   */\n\n\n  toRawType() {\n    return 'StorageKey';\n  }\n\n}\n\nexports.default = StorageKey;","map":null,"metadata":{},"sourceType":"script"}