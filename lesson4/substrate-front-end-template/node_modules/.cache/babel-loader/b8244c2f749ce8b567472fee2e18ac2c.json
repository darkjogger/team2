{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Keyring = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _pair = _interopRequireDefault(require(\"@polkadot/keyring/pair\"));\n\nvar _chains = _interopRequireDefault(require(\"@polkadot/ui-settings/defaults/chains\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _development = _interopRequireDefault(require(\"./observable/development\"));\n\nvar _Base = _interopRequireDefault(require(\"./Base\"));\n\nvar _defaults = require(\"./defaults\");\n\nvar _options = _interopRequireDefault(require(\"./options\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst RECENT_EXPIRY = 24 * 60 * 60; // No accounts (or test accounts) should be loaded until after the chain determination.\n// Chain determination occurs outside of Keyring. Loading `keyring.loadAll({ type: 'ed25519' | 'sr25519' })` is triggered\n// from the API after the chain is received\n\nclass Keyring extends _Base.default {\n  constructor(...args) {\n    super(...args);\n    Object.defineProperty(this, _stores, {\n      writable: true,\n      value: {\n        account: () => this.accounts,\n        address: () => this.addresses,\n        contract: () => this.contracts\n      }\n    });\n  }\n\n  addExternal(address, meta = {}) {\n    const pair = this.keyring.addFromAddress(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isExternal: true\n    }), null);\n    return {\n      json: this.saveAccount(pair),\n      pair\n    };\n  }\n\n  addHardware(address, hardwareType, meta = {}) {\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      hardwareType,\n      isHardware: true\n    }));\n  }\n\n  addMultisig(addresses, threshold, meta = {}) {\n    const address = (0, _utilCrypto.createKeyMulti)(addresses, threshold); // we could use `sortAddresses`, but rather use internal encode/decode so we are 100%\n\n    const who = (0, _util.u8aSorted)(addresses.map(who => this.decodeAddress(who))).map(who => this.encodeAddress(who));\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isMultisig: true,\n      threshold: (0, _util.bnToBn)(threshold).toNumber(),\n      who\n    }));\n  }\n\n  addPair(pair, password) {\n    this.keyring.addPair(pair);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  addUri(suri, password, meta = {}, type) {\n    const pair = this.keyring.addFromUri(suri, meta, type);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  backupAccount(pair, password) {\n    if (!pair.isLocked) {\n      pair.lock();\n    }\n\n    pair.decodePkcs8(password);\n    return pair.toJson(password);\n  }\n\n  createFromUri(suri, meta = {}, type) {\n    return this.keyring.createFromUri(suri, meta, type);\n  }\n\n  encryptAccount(pair, password) {\n    const json = pair.toJson(password);\n    json.meta.whenEdited = Date.now();\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json);\n  }\n\n  forgetAccount(address) {\n    this.keyring.removePair(address);\n    this.accounts.remove(this._store, address);\n  }\n\n  forgetAddress(address) {\n    this.addresses.remove(this._store, address);\n  }\n\n  forgetContract(address) {\n    this.contracts.remove(this._store, address);\n  }\n\n  getAccount(address) {\n    return this.getAddress(address, 'account');\n  }\n\n  getAccounts() {\n    const available = this.accounts.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address, 'account')).filter(account => _development.default.isDevelopment() || account.meta.isTesting !== true);\n  }\n\n  getAddress(_address, type = null) {\n    const address = (0, _util.isString)(_address) ? _address : this.encodeAddress(_address);\n    const publicKey = this.decodeAddress(address);\n    const stores = type ? [(0, _classPrivateFieldLooseBase2.default)(this, _stores)[_stores][type]] : Object.values((0, _classPrivateFieldLooseBase2.default)(this, _stores)[_stores]);\n    const info = stores.reduce((lastInfo, store) => store().subject.getValue()[address] || lastInfo, undefined);\n    return info && {\n      address,\n      meta: info.json.meta,\n      publicKey\n    };\n  }\n\n  getAddresses() {\n    const available = this.addresses.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address));\n  }\n\n  getContract(address) {\n    return this.getAddress(address, 'contract');\n  }\n\n  getContracts() {\n    const available = this.contracts.subject.getValue();\n    return Object.entries(available).filter(([, {\n      json: {\n        meta: {\n          contract\n        }\n      }\n    }]) => !!contract && contract.genesisHash === this.genesisHash).map(([address]) => this.getContract(address));\n  }\n\n  rewriteKey(json, key, hexAddr, creator) {\n    if (hexAddr.substr(0, 2) === '0x') {\n      return;\n    }\n\n    this._store.remove(key);\n\n    this._store.set(creator(hexAddr), json);\n  }\n\n  loadAccount(json, key) {\n    if (!json.meta.isTesting && json.encoded) {\n      // FIXME Just for the transition period (ignoreChecksum)\n      const pair = this.keyring.addFromJson(json, true);\n      this.accounts.add(this._store, pair.address, json);\n    }\n\n    const [, hexAddr] = key.split(':');\n    this.rewriteKey(json, key, hexAddr.trim(), _defaults.accountKey);\n  }\n\n  loadAddress(json, key) {\n    const {\n      isRecent,\n      whenCreated = 0\n    } = json.meta;\n\n    if (isRecent && Date.now() - whenCreated > RECENT_EXPIRY) {\n      this._store.remove(key);\n\n      return;\n    }\n\n    const address = this.encodeAddress((0, _util.isHex)(json.address) ? (0, _util.hexToU8a)(json.address) // FIXME Just for the transition period (ignoreChecksum)\n    : this.decodeAddress(json.address, true));\n    const [, hexAddr] = key.split(':');\n    this.addresses.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, _defaults.addressKey);\n  }\n\n  loadContract(json, key) {\n    const address = this.encodeAddress(this.decodeAddress(json.address));\n    const [, hexAddr] = key.split(':'); // move genesisHash to top-level (TODO Remove from contracts section?)\n\n    json.meta.genesisHash = json.meta.genesisHash || json.meta.contract && json.meta.contract.genesisHash;\n    this.contracts.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, _defaults.contractKey);\n  }\n\n  loadInjected(address, meta) {\n    const json = {\n      address,\n      meta: _objectSpread(_objectSpread({}, meta), {}, {\n        isInjected: true\n      })\n    };\n    const pair = this.keyring.addFromAddress(address, json.meta);\n    this.accounts.add(this._store, pair.address, json);\n  }\n\n  allowGenesis(json) {\n    if (json && json.meta && this.genesisHash) {\n      const hashes = Object.values(_chains.default).find(hashes => hashes.includes(this.genesisHash || '')) || [this.genesisHash];\n\n      if (json.meta.genesisHash) {\n        return hashes.includes(json.meta.genesisHash);\n      } else if (json.meta.contract) {\n        return hashes.includes(json.meta.contract.genesisHash);\n      }\n    }\n\n    return true;\n  }\n\n  loadAll(options, injected = []) {\n    super.initKeyring(options);\n\n    this._store.all((key, json) => {\n      if (options.filter ? options.filter(json) : true) {\n        if (this.allowGenesis(json)) {\n          if (_defaults.accountRegex.test(key)) {\n            this.loadAccount(json, key);\n          } else if (_defaults.addressRegex.test(key)) {\n            this.loadAddress(json, key);\n          } else if (_defaults.contractRegex.test(key)) {\n            this.loadContract(json, key);\n          }\n        }\n      }\n    });\n\n    injected.forEach(account => {\n      if (this.allowGenesis(account)) {\n        this.loadInjected(account.address, account.meta);\n      }\n    });\n\n    _options.default.init(this);\n  }\n\n  restoreAccount(json, password) {\n    const type = Array.isArray(json.encoding.content) ? json.encoding.content[1] : 'ed25519';\n    const pair = (0, _pair.default)({\n      toSS58: this.encodeAddress,\n      type\n    }, {\n      // FIXME Just for the transition period (ignoreChecksum)\n      publicKey: this.decodeAddress(json.address, true)\n    }, json.meta, (0, _util.hexToU8a)(json.encoded)); // unlock, save account and then lock (locking cleans secretKey, so needs to be last)\n\n    pair.decodePkcs8(password);\n    this.addPair(pair, password);\n    pair.lock();\n    return pair;\n  }\n\n  saveAccount(pair, password) {\n    this.addTimestamp(pair);\n    const json = pair.toJson(password);\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json);\n    return json;\n  }\n\n  saveAccountMeta(pair, meta) {\n    const address = pair.address;\n\n    this._store.get((0, _defaults.accountKey)(address), json => {\n      pair.setMeta(meta);\n      json.meta = pair.meta;\n      this.accounts.add(this._store, address, json);\n    });\n  }\n\n  saveAddress(address, meta, type = 'address') {\n    const available = this.addresses.subject.getValue();\n    const json = available[address] && available[address].json || {\n      address,\n      meta: {\n        isRecent: undefined,\n        whenCreated: Date.now()\n      }\n    };\n    Object.keys(meta).forEach(key => {\n      json.meta[key] = meta[key];\n    });\n    delete json.meta.isRecent;\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _stores)[_stores][type]().add(this._store, address, json);\n\n    return json;\n  }\n\n  saveContract(address, meta) {\n    return this.saveAddress(address, meta, 'contract');\n  }\n\n  saveRecent(address) {\n    const available = this.addresses.subject.getValue();\n\n    if (!available[address]) {\n      this.addresses.add(this._store, address, {\n        address,\n        meta: {\n          genesisHash: this.genesisHash,\n          isRecent: true,\n          whenCreated: Date.now()\n        }\n      });\n    }\n\n    return this.addresses.subject.getValue()[address];\n  }\n\n}\n\nexports.Keyring = Keyring;\n\nvar _stores = (0, _classPrivateFieldLooseKey2.default)(\"stores\");\n\nconst keyringInstance = new Keyring();\nvar _default = keyringInstance;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}