{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _memoizee = _interopRequireDefault(require(\"memoizee\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _jsonrpc = _interopRequireDefault(require(\"@polkadot/types/interfaces/jsonrpc\"));\n\nvar _types = require(\"@polkadot/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _rxjs2 = require(\"./rxjs\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst l = (0, _util.logger)('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n}; // utility method to create a nicely-formatted error\n\n/** @internal */\n\nfunction logErrorMessage(method, {\n  params,\n  type\n}, error) {\n  const inputs = params.map(({\n    isOptional,\n    name,\n    type\n  }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ');\n  l.error(`${method}(${inputs}): ${type}:: ${error.message}`);\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import WsProvider from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\n\n\nclass Rpc {\n  // Ok, this is quite horrible - we really should not be using the ! here, but we are actually assigning\n  // these via the createInterfaces inside the constructor. However... this is not quite visible. The reason\n  // why we don't do for individual assignments is to allow user-defined RPCs to also be defined\n\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  constructor(registry, provider, userRpc = {}) {\n    Object.defineProperty(this, _storageCache, {\n      writable: true,\n      value: new Map()\n    });\n    this.mapping = new Map();\n    this.provider = void 0;\n    this.registry = void 0;\n    this.sections = [];\n    this.account = void 0;\n    this.author = void 0;\n    this.babe = void 0;\n    this.chain = void 0;\n    this.childstate = void 0;\n    this.contracts = void 0;\n    this.engine = void 0;\n    this.grandpa = void 0;\n    this.offchain = void 0;\n    this.payment = void 0;\n    this.rpc = void 0;\n    this.state = void 0;\n    this.system = void 0; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n    (0, _util.assert)(provider && (0, _util.isFunction)(provider.send), 'Expected Provider to API create');\n    this.registry = registry;\n    this.provider = provider;\n\n    this._createInterfaces(userRpc);\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n\n\n  disconnect() {\n    this.provider.disconnect();\n  }\n\n  _createInterfaces(userRpc) {\n    const sectionNames = Object.keys(_jsonrpc.default); // these are the base keys (i.e. part of jsonrpc)\n\n    this.sections.push(...sectionNames); // add any extra user-defined sections\n\n    this.sections.push(...Object.keys(userRpc).filter(key => !this.sections.includes(key))); // decorate the sections with base and user methods\n\n    this.sections.forEach(sectionName => {\n      this[sectionName] = _objectSpread(_objectSpread({}, this._createInterface(sectionName, _jsonrpc.default[sectionName] || {})), this._createInterface(sectionName, userRpc[sectionName] || {}));\n    });\n  }\n\n  _createInterface(section, methods) {\n    return Object.keys(methods).reduce((exposed, method) => {\n      const def = methods[method];\n      const isSubscription = !!def.pubsub;\n      this.mapping.set(`${section}_${method}`, _objectSpread(_objectSpread({}, def), {}, {\n        isSubscription,\n        jsonrpc: `${section}_${method}`,\n        method,\n        section\n      })); // FIXME Remove any here\n      // To do so, remove `RpcInterfaceMethod` from './types.ts', and refactor\n      // every method inside this class to take:\n      // `<S extends keyof RpcInterface, M extends keyof RpcInterface[S]>`\n      // Not doing so, because it makes this class a little bit less readable,\n      // and leaving it as-is doesn't harm much\n\n      exposed[method] = isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def);\n      return exposed;\n    }, {});\n  }\n\n  _createMethodWithRaw(creator) {\n    const call = creator(false);\n    call.raw = creator(true);\n    return call;\n  }\n\n  _createMethodSend(section, method, def) {\n    const rpcName = `${section}_${method}`;\n\n    const creator = isRaw => (...values) => {\n      // Here, logically, it should be `of(this.formatInputs(method, values))`.\n      // However, formatInputs can throw, and when it does, the above way\n      // doesn't throw in the \"Observable loop\" (which is internally wrapped in\n      // a try/catch block). So we:\n      // - first do `of(1)` - won't throw\n      // - then do `map(()=>this.formatInputs)` - might throw, but inside Observable.\n      return (0, _rxjs.of)(1).pipe((0, _operators.map)(() => this._formatInputs(def, values)), (0, _operators.switchMap)(params => (0, _rxjs.combineLatest)([(0, _rxjs.of)(params), (0, _rxjs.from)(this.provider.send(rpcName, params.map(param => param.toJSON())))])), (0, _operators.map)(([params, result]) => isRaw ? this.registry.createType('Raw', result) : this._formatOutput(method, def, params, result)), (0, _operators.catchError)(error => {\n        logErrorMessage(method, def, error);\n        return (0, _rxjs.throwError)(error);\n      }), (0, _operators.publishReplay)(1), // create a Replay(1)\n      (0, _operators.refCount)() // Unsubscribe WS when there are no more subscribers\n      );\n    }; // We voluntarily don't cache the \"one-shot\" RPC calls. For example,\n    // `getStorage('123')` returns the current value, but this value can change\n    // over time, so we wouldn't want to cache the Observable.\n\n\n    return this._createMethodWithRaw(creator);\n  } // create a subscriptor, it subscribes once and resolves with the id as subscribe\n\n\n  _createSubscriber({\n    paramsJson,\n    subName,\n    subType,\n    update\n  }, errorHandler) {\n    return new Promise((resolve, reject) => {\n      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {\n        errorHandler(error);\n        reject(error);\n      });\n    });\n  }\n\n  _createMethodSubscribe(section, method, def) {\n    const [updateType, subMethod, unsubMethod] = def.pubsub;\n    const subName = `${section}_${subMethod}`;\n    const unsubName = `${section}_${unsubMethod}`;\n    const subType = `${section}_${updateType}`;\n\n    const creator = isRaw => (...values) => {\n      return new _rxjs.Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve();\n\n        const errorHandler = error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n        };\n\n        try {\n          const params = this._formatInputs(def, values);\n\n          const paramsJson = params.map(param => param.toJSON());\n\n          const update = (error, result) => {\n            if (error) {\n              logErrorMessage(method, def, error);\n              return;\n            }\n\n            try {\n              observer.next(isRaw ? this.registry.createType('Raw', result) : this._formatOutput(method, def, params, result));\n            } catch (error) {\n              observer.error(error);\n            }\n          };\n\n          subscriptionPromise = this._createSubscriber({\n            paramsJson,\n            subName,\n            subType,\n            update\n          }, errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        } // Teardown logic\n\n\n        return () => {\n          // Delete from cache\n          // Reason:\n          // ```\n          //    const s = api.query.system.account(addr1).subscribe(); // let's say it's 6\n          //    s.unsubscribe();\n          //    // wait a bit, for the nonce to increase to 7\n          //    api.query.system.account(addr1).subscribe(); // will output 6 instead of 7 if we don't clear cache\n          //    // that's because all our observables are replay(1)\n          // ```\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          memoized.delete(...values); // Unsubscribe from provider\n\n          subscriptionPromise.then(subscriptionId => (0, _util.isNumber)(subscriptionId) ? this.provider.unsubscribe(subType, unsubName, subscriptionId) : Promise.resolve(false)).catch(error => logErrorMessage(method, def, error));\n        };\n      }).pipe((0, _rxjs2.drr)());\n    };\n\n    const memoized = (0, _memoizee.default)(this._createMethodWithRaw(creator), {\n      // Dynamic length for argument\n      length: false,\n      // Normalize args so that different args that should be cached\n      // together are cached together.\n      // E.g.: `query.my.method('abc') === query.my.method(createType('AccountId', 'abc'));`\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      normalizer: JSON.stringify\n    });\n    return memoized;\n  }\n\n  _formatInputs(def, inputs) {\n    const reqArgCount = def.params.filter(({\n      isOptional\n    }) => !isOptional).length;\n    const optText = reqArgCount === def.params.length ? '' : ` (${def.params.length - reqArgCount} optional)`;\n    (0, _util.assert)(inputs.length >= reqArgCount && inputs.length <= def.params.length, `Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);\n    return inputs.map((input, index) => (0, _types.createTypeUnsafe)(this.registry, def.params[index].type, [input]));\n  }\n\n  _treatAsHex(key) {\n    // :code is problematic - it does not have the length attached, which is\n    // unlike all other storage entries where it is indeed properly encoded\n    return ['0x3a636f6465'].includes(key.toHex());\n  }\n\n  _formatOutput(method, rpc, params, result) {\n    if (rpc.type === 'StorageData') {\n      const key = params[0];\n\n      try {\n        return this._formatStorageData(key, result);\n      } catch (error) {\n        console.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:`, error.message);\n        throw error;\n      }\n    } else if (rpc.type === 'StorageChangeSet') {\n      const keys = params[0];\n      return keys ? this._formatStorageSet(keys, result.changes) : this.registry.createType('StorageChangeSet', result);\n    } else if (rpc.type === 'Vec<StorageChangeSet>') {\n      const mapped = result.map(({\n        block,\n        changes\n      }) => [this.registry.createType('Hash', block), this._formatStorageSet(params[0], changes)]); // we only query at a specific block, not a range - flatten\n\n      return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n    }\n\n    return (0, _types.createTypeUnsafe)(this.registry, rpc.type, [result]);\n  }\n\n  _formatStorageData(key, value) {\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Raw on nothing\n    const type = key.outputType || 'Raw';\n    const meta = key.meta || EMPTY_META;\n    const isEmpty = (0, _util.isNull)(value); // we convert to Uint8Array since it maps to the raw encoding, all\n    // data will be correctly encoded (incl. numbers, excl. :code)\n\n    const input = isEmpty ? null : this._treatAsHex(key) ? value : (0, _util.u8aToU8a)(value);\n\n    if (meta.modifier.isOptional) {\n      return new _types.Option(this.registry, (0, _types.createClass)(this.registry, type), isEmpty ? null : (0, _types.createTypeUnsafe)(this.registry, type, [input], true));\n    }\n\n    return (0, _types.createTypeUnsafe)(this.registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], true);\n  }\n\n  _formatStorageSet(keys, changes) {\n    // For StorageChangeSet, the changes has the [key, value] mappings\n    const withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values\n    // one at a time, all based on the query types. Three values can be returned -\n    //   - Codec - There is a valid value, non-empty\n    //   - null - The storage key is empty\n\n    return keys.reduce((results, key) => {\n      try {\n        results.push(this._formatStorageSetEntry(key, changes, withCache));\n      } catch (error) {\n        console.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:`, error.message);\n        throw error;\n      }\n\n      return results;\n    }, []);\n  }\n\n  _formatStorageSetEntry(key, changes, witCache) {\n    // Fallback to Raw (i.e. just the encoding) if we don't have a specific type\n    const type = key.outputType || 'Raw';\n    const hexKey = key.toHex();\n    const meta = key.meta || EMPTY_META;\n    const found = changes.find(([key]) => key === hexKey); // if we don't find the value, this is our fallback\n    //   - in the case of an array of values, fill the hole from the cache\n    //   - if a single result value, don't fill - it is not an update hole\n    //   - fallback to an empty option in all cases\n\n    const value = (0, _util.isUndefined)(found) ? witCache && (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];\n    const isEmpty = (0, _util.isNull)(value);\n    const input = isEmpty || this._treatAsHex(key) ? value : (0, _util.u8aToU8a)(value); // store the retrieved result - the only issue with this cache is that there is no\n    // clearing of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].set(hexKey, value);\n\n    if (meta.modifier.isOptional) {\n      return new _types.Option(this.registry, (0, _types.createClass)(this.registry, type), isEmpty ? null : (0, _types.createTypeUnsafe)(this.registry, type, [input], true));\n    }\n\n    return (0, _types.createTypeUnsafe)(this.registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], true);\n  }\n\n}\n\nexports.default = Rpc;\n\nvar _storageCache = (0, _classPrivateFieldLooseKey2.default)(\"storageCache\");","map":null,"metadata":{},"sourceType":"script"}