{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.paramsNotation = paramsNotation;\nexports.encodeType = encodeType;\nexports.displayType = displayType;\nexports.withTypeString = withTypeString;\nexports.SPECIAL_TYPES = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _types = require(\"../../create/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst SPECIAL_TYPES = ['AccountId', 'AccountIndex', 'Address', 'Balance'];\nexports.SPECIAL_TYPES = SPECIAL_TYPES;\n\nconst identity = value => value;\n\nfunction paramsNotation(outer, inner, transform = identity) {\n  let arrayStr = '';\n\n  if (inner) {\n    arrayStr = '<' + (Array.isArray(inner) ? inner : [inner]).map(transform).join(', ') + '>';\n  }\n\n  return `${outer}${arrayStr}`;\n} // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\nfunction encodeWithParams(typeDef, outer = typeDef.displayName || typeDef.type) {\n  const {\n    info,\n    params,\n    sub\n  } = typeDef;\n\n  switch (info) {\n    case _types.TypeDefInfo.BTreeMap:\n    case _types.TypeDefInfo.BTreeSet:\n    case _types.TypeDefInfo.Compact:\n    case _types.TypeDefInfo.HashMap:\n    case _types.TypeDefInfo.Linkage:\n    case _types.TypeDefInfo.Option:\n    case _types.TypeDefInfo.Result:\n    case _types.TypeDefInfo.Vec:\n      return paramsNotation(outer, params || sub, // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      param => displayType(param));\n\n    default:\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return outer;\n  }\n}\n\nfunction encodeDoNotConstruct({\n  displayName\n}) {\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  return `DoNotEncode<${displayName}>`;\n}\n\nfunction encodeSubTypes(sub, asEnum) {\n  const inner = sub.reduce((result, type) => {\n    return _objectSpread(_objectSpread({}, result), {}, {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      [type.name]: encodeType(type)\n    });\n  }, {});\n  return JSON.stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n}\n\nfunction encodeEnum(typeDef) {\n  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Enum type');\n  const sub = typeDef.sub;\n  const isClikeEnum = sub.reduce((bool, {\n    type\n  }) => bool && type === 'Null', true);\n\n  if (isClikeEnum) {\n    return `[${sub // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    .map(({\n      name\n    }) => `\"${name}\"`).join(', ')}]`;\n  }\n\n  return encodeSubTypes(sub, true);\n}\n\nfunction encodeStruct(typeDef) {\n  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Struct type');\n  const sub = typeDef.sub;\n  return encodeSubTypes(sub);\n}\n\nfunction encodeTuple(typeDef) {\n  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Tuple type');\n  const sub = typeDef.sub;\n  return `(${sub // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  .map(type => encodeType(type)).join(', ')})`;\n}\n\nfunction encodeUInt({\n  length\n}, type) {\n  (0, _util.assert)((0, _util.isNumber)(length), 'Unable to encode VecFixed type');\n  return `${type}<${length}>`;\n}\n\nfunction encodeVecFixed({\n  length,\n  sub\n}) {\n  (0, _util.assert)((0, _util.isNumber)(length) && !(0, _util.isUndefined)(sub), 'Unable to encode VecFixed type'); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/restrict-template-expressions\n\n  return `[${sub.type};${length}]`;\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nconst encoders = {\n  [_types.TypeDefInfo.BTreeMap]: typeDef => encodeWithParams(typeDef, 'BTreeMap'),\n  [_types.TypeDefInfo.BTreeSet]: typeDef => encodeWithParams(typeDef, 'BTreeSet'),\n  [_types.TypeDefInfo.Compact]: typeDef => encodeWithParams(typeDef, 'Compact'),\n  [_types.TypeDefInfo.DoNotConstruct]: typeDef => encodeDoNotConstruct(typeDef),\n  [_types.TypeDefInfo.Enum]: typeDef => encodeEnum(typeDef),\n  [_types.TypeDefInfo.HashMap]: typeDef => encodeWithParams(typeDef, 'HashMap'),\n  [_types.TypeDefInfo.Int]: typeDef => encodeUInt(typeDef, 'Int'),\n  [_types.TypeDefInfo.Linkage]: typeDef => encodeWithParams(typeDef, 'Linkage'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [_types.TypeDefInfo.Null]: typeDef => 'Null',\n  [_types.TypeDefInfo.Option]: typeDef => encodeWithParams(typeDef, 'Option'),\n  [_types.TypeDefInfo.Plain]: typeDef => typeDef.displayName || typeDef.type,\n  [_types.TypeDefInfo.Result]: typeDef => encodeWithParams(typeDef, 'Result'),\n  [_types.TypeDefInfo.Set]: typeDef => typeDef.type,\n  [_types.TypeDefInfo.Struct]: typeDef => encodeStruct(typeDef),\n  [_types.TypeDefInfo.Tuple]: typeDef => encodeTuple(typeDef),\n  [_types.TypeDefInfo.UInt]: typeDef => encodeUInt(typeDef, 'UInt'),\n  [_types.TypeDefInfo.Vec]: typeDef => encodeWithParams(typeDef, 'Vec'),\n  [_types.TypeDefInfo.VecFixed]: typeDef => encodeVecFixed(typeDef)\n};\n\nfunction encodeType(typeDef) {\n  const encoder = encoders[typeDef.info];\n  (0, _util.assert)(encoder, `Cannot encode type: ${typeDef.toString()}`);\n  return encoder(typeDef);\n}\n\nfunction displayType(typeDef) {\n  if (typeDef.displayName) {\n    return encodeWithParams(typeDef);\n  }\n\n  switch (typeDef.info) {\n    case _types.TypeDefInfo.Struct:\n    case _types.TypeDefInfo.Enum:\n      return encodeWithParams(typeDef);\n\n    default:\n      return encodeType(typeDef);\n  }\n}\n\nfunction withTypeString(typeDef) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const type = SPECIAL_TYPES.includes(typeDef.displayName) ? typeDef.displayName : encodeType(typeDef);\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    type\n  });\n}","map":null,"metadata":{},"sourceType":"script"}