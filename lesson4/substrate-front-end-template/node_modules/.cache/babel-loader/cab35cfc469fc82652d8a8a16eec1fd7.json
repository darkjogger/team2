{"ast":null,"code":"import { useContext, useEffect, useCallback } from 'react';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { web3Accounts, web3Enable } from '@polkadot/extension-dapp';\nimport keyring from '@polkadot/ui-keyring';\nimport config from '../config';\nimport { SubstrateContext } from './SubstrateContext';\n\nconst useSubstrate = () => {\n  const [state, dispatch] = useContext(SubstrateContext); // `useCallback` so that returning memoized function and not created\n  //   everytime, and thus re-render.\n\n  const {\n    api,\n    socket,\n    types\n  } = state;\n  const connect = useCallback(async () => {\n    if (api) return;\n    const provider = new WsProvider(socket);\n\n    const _api = new ApiPromise({\n      provider,\n      types\n    }); // We want to listen to event for disconnection and reconnection.\n    //  That's why we set for listeners.\n\n\n    _api.on('connected', () => {\n      dispatch({\n        type: 'CONNECT',\n        payload: _api\n      }); // `ready` event is not emitted upon reconnection. So we check explicitly here.\n\n      _api.isReady.then(_api => dispatch({\n        type: 'CONNECT_SUCCESS'\n      }));\n    });\n\n    _api.on('ready', () => dispatch({\n      type: 'CONNECT_SUCCESS'\n    }));\n\n    _api.on('error', () => dispatch({\n      type: 'CONNECT_ERROR'\n    }));\n  }, [api, socket, types, dispatch]); // hook to get injected accounts\n\n  const {\n    keyringState\n  } = state;\n  const loadAccounts = useCallback(async () => {\n    // Ensure the method only run once.\n    if (keyringState) return;\n\n    try {\n      await web3Enable(config.APP_NAME);\n      let allAccounts = await web3Accounts();\n      allAccounts = allAccounts.map(({\n        address,\n        meta\n      }) => ({\n        address,\n        meta: { ...meta,\n          name: `${meta.name} (${meta.source})`\n        }\n      }));\n      keyring.loadAll({\n        isDevelopment: config.DEVELOPMENT_KEYRING\n      }, allAccounts);\n      dispatch({\n        type: 'SET_KEYRING',\n        payload: keyring\n      });\n    } catch (e) {\n      console.error(e);\n      dispatch({\n        type: 'KEYRING_ERROR'\n      });\n    }\n  }, [keyringState, dispatch]);\n  useEffect(() => {\n    connect();\n  }, [connect]);\n  useEffect(() => {\n    loadAccounts();\n  }, [loadAccounts]);\n  return { ...state,\n    dispatch\n  };\n};\n\nexport default useSubstrate;","map":{"version":3,"sources":["/Users/binggao/Documents/GitHub/team2/lesson3/substrate-front-end-template/src/substrate-lib/useSubstrate.js"],"names":["useContext","useEffect","useCallback","ApiPromise","WsProvider","web3Accounts","web3Enable","keyring","config","SubstrateContext","useSubstrate","state","dispatch","api","socket","types","connect","provider","_api","on","type","payload","isReady","then","keyringState","loadAccounts","APP_NAME","allAccounts","map","address","meta","name","source","loadAll","isDevelopment","DEVELOPMENT_KEYRING","e","console","error"],"mappings":"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","sourcesContent":["import { useContext, useEffect, useCallback } from 'react';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { web3Accounts, web3Enable } from '@polkadot/extension-dapp';\nimport keyring from '@polkadot/ui-keyring';\n\nimport config from '../config';\nimport { SubstrateContext } from './SubstrateContext';\n\nconst useSubstrate = () => {\n  const [state, dispatch] = useContext(SubstrateContext);\n\n  // `useCallback` so that returning memoized function and not created\n  //   everytime, and thus re-render.\n  const { api, socket, types } = state;\n  const connect = useCallback(async () => {\n    if (api) return;\n\n    const provider = new WsProvider(socket);\n    const _api = new ApiPromise({ provider, types });\n\n    // We want to listen to event for disconnection and reconnection.\n    //  That's why we set for listeners.\n    _api.on('connected', () => {\n      dispatch({ type: 'CONNECT', payload: _api });\n      // `ready` event is not emitted upon reconnection. So we check explicitly here.\n      _api.isReady.then((_api) => dispatch({ type: 'CONNECT_SUCCESS' }));\n    });\n    _api.on('ready', () => dispatch({ type: 'CONNECT_SUCCESS' }));\n    _api.on('error', () => dispatch({ type: 'CONNECT_ERROR' }));\n  }, [api, socket, types, dispatch]);\n\n  // hook to get injected accounts\n  const { keyringState } = state;\n  const loadAccounts = useCallback(async () => {\n    // Ensure the method only run once.\n    if (keyringState) return;\n\n    try {\n      await web3Enable(config.APP_NAME);\n      let allAccounts = await web3Accounts();\n      allAccounts = allAccounts.map(({ address, meta }) =>\n        ({ address, meta: { ...meta, name: `${meta.name} (${meta.source})` } }));\n\n      keyring.loadAll({ isDevelopment: config.DEVELOPMENT_KEYRING }, allAccounts);\n      dispatch({ type: 'SET_KEYRING', payload: keyring });\n    } catch (e) {\n      console.error(e);\n      dispatch({ type: 'KEYRING_ERROR' });\n    }\n  }, [keyringState, dispatch]);\n\n  useEffect(() => {\n    connect();\n  }, [connect]);\n\n  useEffect(() => {\n    loadAccounts();\n  }, [loadAccounts]);\n\n  return { ...state, dispatch };\n};\n\nexport default useSubstrate;\n"]},"metadata":{},"sourceType":"module"}